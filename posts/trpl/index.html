<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Notes on The Rust Programming Language | mrr1vfe</title><meta name=keywords content="Rust"><meta name=description content="Common Programming Concepts 1  Variables and Mutability    The default integer type for a positive number that is not so large is i32.
  Variables by default are immutable.
  Differences Between Variables and Constants    mut cannot be used with constants.
  Declare constants with const keyword, and the type must be annotated.
  Constant can only be set to constant expression, not value computed during runtime."><meta name=author content="Reid Chen"><link rel=canonical href=https://www.mrr1vfe.io/posts/trpl/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.mrr1vfe.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.mrr1vfe.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.mrr1vfe.io/favicon-32x32.png><link rel=apple-touch-icon href=https://www.mrr1vfe.io/apple-touch-icon.png><link rel=mask-icon href=https://www.mrr1vfe.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.0"><meta property="og:title" content="Notes on The Rust Programming Language"><meta property="og:description" content="Common Programming Concepts 1  Variables and Mutability    The default integer type for a positive number that is not so large is i32.
  Variables by default are immutable.
  Differences Between Variables and Constants    mut cannot be used with constants.
  Declare constants with const keyword, and the type must be annotated.
  Constant can only be set to constant expression, not value computed during runtime."><meta property="og:type" content="article"><meta property="og:url" content="https://www.mrr1vfe.io/posts/trpl/"><meta property="og:image" content="https://www.mrr1vfe.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-30T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-30T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.mrr1vfe.io/papermod-cover.png"><meta name=twitter:title content="Notes on The Rust Programming Language"><meta name=twitter:description content="Common Programming Concepts 1  Variables and Mutability    The default integer type for a positive number that is not so large is i32.
  Variables by default are immutable.
  Differences Between Variables and Constants    mut cannot be used with constants.
  Declare constants with const keyword, and the type must be annotated.
  Constant can only be set to constant expression, not value computed during runtime."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.mrr1vfe.io/posts/"},{"@type":"ListItem","position":2,"name":"Notes on The Rust Programming Language","item":"https://www.mrr1vfe.io/posts/trpl/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Notes on The Rust Programming Language","name":"Notes on The Rust Programming Language","description":"Common Programming Concepts 1  Variables and Mutability    The default integer type for a positive number that is not so large is i32.\n  Variables by default are immutable.\n  Differences Between Variables and Constants    mut cannot be used with constants.\n  Declare constants with const keyword, and the type must be annotated.\n  Constant can only be set to constant expression, not value computed during runtime.","keywords":["Rust"],"articleBody":" Common Programming Concepts 1  Variables and Mutability    The default integer type for a positive number that is not so large is i32.\n  Variables by default are immutable.\n  Differences Between Variables and Constants    mut cannot be used with constants.\n  Declare constants with const keyword, and the type must be annotated.\n  Constant can only be set to constant expression, not value computed during runtime.\n    Shadowing    You can declare a new variable with the same name as a previous variable and the new variable shadows the previous variable.\n  Type can be changed when shadowing.\n  Type cannot be changed when re-assigning a value with a different type to a mutable variable\n      Data Types    Rust must know the types of all variables at compile time.\n  Scalar Types    scalar type   Type represents a single value.\n    Integer Types    Size of isize and usize depends on the architecture of which program runs on. 32 bits if running on a 32-bit architecture.\n  Integer literals support _ as a visual separator.\n  Default type is i32.\n    Floating-Point Types    There are f32 or f64 in Rust. There is no double.\n  Default type is f64.\n    Numeric Operations    Division behaves in the same way as C.\n    Boolean Type    Type bool has too possible values, true or false.\n    Character Type    Size of 4 bytes\n  Represents a Unicode Scalar Value.\n    Compound Types    compound types   Can group multiple values into one type.\n    Tuple Type    Create a tuple by writing a comma-separated list of values inside parentheses.\n  Each position in the parentheses has a type.\n  These types do not have to be the same.\n  fn main() { let tup: (i32, f32, i8) = (500, 6.4, 1); let (x, y, z) = tup; println!(\"The value of y is {}\", y); }    One way to access a value inside a tuple is destructuring through pattern matching.\n  Another way to access a value is using . with an index. The first element in the tuple is indexed 0.\n  fn main() { let tup: (i32, f32, i8) = (500, 6.4, 1) println!(\"The value of y is {}\", tup.1); }    Array Type    Each element in an array must has the same type.\n  Arrays in rust have fixed length.\n  Arrays are allocated on stack.\n  Type on an array is a composition of its elements' type and its length.\nlet a: [u8; 3] = [1, 2, 3];    An array can be initialized in the following way if each element has the same value.\nlet a = [4; 8]; // 8 elements, each element has a value of 4.     Accessing Array Element    Element can be accessed using indexing.\n  Rust will check if an index is in the bound in runtime.\n        Functions    fn allows you to declare a new function.\n  Functions can be defined anywhere in the source code.\n  Parameters of a function must have types declared.\n  Instructions that perform some action and do not return a value are statements.\n  Expressions Evaluate to a resulting value.\n  Expressions can be part of statements.\n  Function bodies are made up of a series of statements optionally ending in an expression.\n  Calling a function is an expression.\n  The block that we use to create new scopes, {}, is an expression.\n  Expressions do not include ending semicolons.\n  Functions with Return Values    Declare return value's type using -.\n  The return value of the function is synonymous with the value of the final expression in the block of the body of a function.\n  To return early, use return.\n      Control Flow    Unlike C, the condition must be a bool.\n  If    if is an expression, so it can be used on the right side of a let statement.\n  All arms must have the same type.\n    Repetition  Loop    The loop keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop by using the keyword break.\n  Value after the break expression will be return.\n    For    For each loop on collection\nlet numbers = [1, 2, 3, 4, 5]; for number in numbers.iter() { println!(\"{}\", number); }    For each loop on range\nfor i in (1..4).rev() { println!(\"{}\", i); }            Using Structs to Structure Related Data  Defining and Instantiating Structs    Using dot notation, ., to get a specific value from a struct.\n  A filed of an immutable struct cannot be modified.\n  If a struct is mutable, the dot notation can both access and modify fields of that struct.\n  Cannot make certain field of a struct mutable.\n  If variable that initialize a field has the same name as the field, no need to repeat the name.\nfn build_user(email: String, username: String) - User { User { email, username, active: true, sign_in_count: 1, } }    When creating a new struct instance with some fields from an old instance, use .. specifies that the remaining fields have the same values as the fields in the given instance.\nlet user2 = User { email: String::from(\"another@example.com\"), username: String::from(\"anotherusername567\"), ..user1 };    Tuple struct does not provide names associated with its fields but types.\nstruct Color(i32, i32, i32); let black = Color(0, 0, 0);      Method Syntax    The first parameter for a method is always self.\n  Methods can also take ownership, like functions.\nstruct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026self) - u32 { self.width * self.height } }    If a method inside impl block does not have self as its first parameter, then this method is considered as associated function.\n  Associated functions can be called by :: syntax.\n  Each struct can have multiple impl blocks.\n      Understanding Ownership  What is Ownership?    All data stored on the stack must have a known, fixed size.\n  Data with an unknown size at compile time or a size that might change must be stored on the heap instead.\n  Ownership Rules\n  Each value in Rust has a variable that's called it s owner.\n  There can only be one owner at a time.\n  When the owner goes out of scope, the value will be dropped.\n    In Rust, the memory is automatically returned once the variable that owns it goes out of scope.\n  Rust calls drop automatically at the closing curly bracket where the variable will go out of scope.\n  Only copying those on the stack and pointers, which are also on the stack, to the heap, but not data on the heap.\n  This sounds like shallow copy, but rust invalid the variable being copied. That is, old variable cannot be read or wrote anymore.\n  This is known as move.\n  Copying everything on the heap is very expensive.\n  rust will never automatically create \"deep\" copies of your data.\n  Use common method clone to create a \"deep\" copy.\n  Ownership and Functions    The semantics for passing a value to a function are similar to those for assigning a value to a variable.\n  When a value passes into a function, the ownership also is passed into the function.\n  Returning a value can also pass ownership.\n      References and Borrowing    Reference allows you to refer to some value without taking ownership of it.\n  The \u0026val syntax lets us create a reference that refers to the value val but does not own it.\n  We don't drop what the reference points to when the reference goes out of scope because we don't have ownership.\n  References are immutable by default.\n  You can have only one mutable reference to a particular piece of data in a particular scope.\n  We also cannot have a mutable reference while we have an immutable one.\n  The scope of a reference starts from where it is introduces and continues through the last time that reference is used.\n  The Rules of References:\n  At any given time, you can have either one mutable reference or any number of immutable references.\n  References must always be valid.\n        Enums and Pattern Matching  Defining an Enum    Enums can have different types.\n  Enums is similar to algebraic data types in functional programming languages.\n  Enums can have methods using impl.\nenum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32), HiTuple((i32, i32)), } impl Message { fn call(\u0026self) { println!(\"Hello Message\"); } }    The Option Enum    Option is provided by Rust, included in prelude.\nenum OptionT { Some(T), None, }    Value of Option typed cannot be used in place of value typed .\n      The match Control Flow Operator    = separates the pattern and the code to run.\n  You can use curly braces if there are multiple lines of code to run after pattern-matched.\n  We must exhaust every last possibility in order for the code to be valid.\n  _ will match any value\n    Concise Control flow with if let    if let matches one pattern.\nif let Some(3) = some_u8_value { println!(\"three\"); }    Compiler does not check if cases are exhaustive.\n  Can be used with a else statement.\n      Common Collections  Vector    Can only store values of the same type\n  When a vector gets dropped, all of its contents are also dropped.\n  Vectors are indexed by number, starting at zero.\n  Adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space.\n    String    The compiler can coerce the \u0026String argument into a \u0026str.\n  Using + to concatenate two strings s1 and s2, let s3 = s1 + \u0026s2, actually takes ownership of s1, appends a copy of the contents of s2, and then returns ownership of the result.\n  Rust strings don't support indexing.\n    Hash Map    The type HashMap stores a mapping of keys of type K to values of type V.\n  We need to first use the HashMap form the collections portion of the standard library.\n  All of keys must have the same type, and all of the values must have the same type.\n  One can use collect method to turn a vector of tuples into a hash map.\n  Types that implement the Copy trait are copied into the hash map.\n  Owned values are moved and the hash map will be the owner of those values.\n  Inserting references to values into the hasp map does not move the value into the hash map.\n  get() returns an Option.\n  Insert a inserted key with different value will replace the old value.\n  Use entry() and or_insert() to insert a value if the key does not appear in the hash map.\n  or_insert() returns a reference to the value associates to the key.\n  Can dereference the return value of or_insert() to update the value.\n      Error Handling  Unrecoverable Errors with panic!    When the panic! macro executes, the program will print a failure message, unwind and clean up the stack, and then quit.\n  Set RUST_BACKTRACE=1 to display the backtrace.\n    Recoverable Errors with Result    Use unwrap() method on Result type. If the value is Ok variant, unwrap will return the value inside the Ok. If the Result is the Err variant, unwrap will call the panic! macro for us.\n  expect() is similar to unwrap(), but more detailed error message can be provided.\n  The ? operator can be used in Functions that return Result.\n      Traits, and Lifetimes  Traits: Defining Shared Behavior    A trait tells the Rust compiler about functionality a particular types has can share with other types.\n  When implementing a trait, put the trait name after impl and then use the for keyword and specify the name of the type we want to implement the trait for.\n  pub makes a trait public so that other crates are able to implement it.\n  We can implement a trait on a type only if either the trait or the type is local to our crate.\n  To use a default implementation, specify and empty impl block.\n  impl can also be used on type parameter.\n  + syntax to specify multiple trait bounds.\n  where clause allows clearer trait bounds.\n  impl Trait syntax can also be used in the return position, but this function should only return a single type.\n  Rust allows conditionally implement a trait.\n    Validating References with Lifetimes  Every reference in Rust has a lifetime.\n  Lifetimes prevent dangling references.\n  The names of lifetime parameters must start with an apostrophe (').\n  We place lifetime parameter annotations after the \u0026 of a reference.\n  When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters.\n  Lifetimes syntax is about connecting the lifetimes of various parameters and return values of functions.\n  Lifetime Elision Rules\n  Each parameter that is a reference gets its own lifetime.\n  If there is exactly one input lifetime parameter, that lifetime is assigned to all.\n  If there are multiple input lifetime parameters, but one of them is \u0026self or \u0026mut self because this is a method, the lifetime of self is assigned to all output lifetime parameters.\n  -'static means that this reference can live for the entire duration of the program.\n      1 Notes from The Rust Programming Language\n    ","wordCount":"2114","inLanguage":"en","datePublished":"2020-04-30T00:00:00Z","dateModified":"2020-04-30T00:00:00Z","author":{"@type":"Person","name":"Reid Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.mrr1vfe.io/posts/trpl/"},"publisher":{"@type":"Organization","name":"mrr1vfe","logo":{"@type":"ImageObject","url":"https://www.mrr1vfe.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://www.mrr1vfe.io/ accesskey=h title="mrr1vfe (Alt + H)">mrr1vfe</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.mrr1vfe.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://www.mrr1vfe.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://www.mrr1vfe.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.mrr1vfe.io/series title=Series><span>Series</span></a></li><li><a href=https://www.mrr1vfe.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://archive.casouri.cat/ title=BHL0388><span>BHL0388</span></a></li><li><a href=https://archive.casouri.cat/goldfish/index.html title=金鱼><span>金鱼</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Notes on The Rust Programming Language</h1><div class=post-meta>April 30, 2020&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Reid Chen</div></header><div class=post-content><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>Common Programming Concepts <sup class=footnote-reference><a id=footnote-reference-1 href=#footnote-1>1</a></sup></h2><div id=outline-text-headline-1 class=outline-text-2><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>Variables and Mutability</h3><div id=outline-text-headline-2 class=outline-text-3><ul><li><p>The default integer type for a positive number that is not so large is <code class=verbatim>i32</code>.</p></li><li><p>Variables by default are <code class=verbatim>immutable</code>.</p></li></ul><div id=outline-container-headline-3 class=outline-4><h4 id=headline-3>Differences Between Variables and Constants</h4><div id=outline-text-headline-3 class=outline-text-4><ul><li><p><code class=verbatim>mut</code> cannot be used with constants.</p></li><li><p>Declare constants with <code class=verbatim>const</code> keyword, and the type must be annotated.</p></li><li><p>Constant can only be set to constant expression, not value computed during runtime.</p></li></ul></div></div><div id=outline-container-headline-4 class=outline-4><h4 id=headline-4>Shadowing</h4><div id=outline-text-headline-4 class=outline-text-4><ul><li><p>You can declare a new variable with the same name as a previous variable and the new variable shadows the previous variable.</p></li><li><p>Type can be changed when shadowing.</p></li><li><p>Type cannot be changed when re-assigning a value with a different type to a mutable variable</p></li></ul></div></div></div></div><div id=outline-container-headline-5 class=outline-3><h3 id=headline-5>Data Types</h3><div id=outline-text-headline-5 class=outline-text-3><ul><li><p>Rust must know the types of all variables at compile time.</p></li></ul><div id=outline-container-headline-6 class=outline-4><h4 id=headline-6>Scalar Types</h4><div id=outline-text-headline-6 class=outline-text-4><dl><dt>scalar type</dt><dd><p>Type represents a single value.</p></dd></dl></div></div><div id=outline-container-headline-7 class=outline-4><h4 id=headline-7>Integer Types</h4><div id=outline-text-headline-7 class=outline-text-4><ul><li><p>Size of <code class=verbatim>isize</code> and <code class=verbatim>usize</code> depends on the architecture of which program runs on. 32 bits if running on a 32-bit architecture.</p></li><li><p>Integer literals support <code class=verbatim>_</code> as a visual separator.</p></li><li><p>Default type is <code class=verbatim>i32</code>.</p></li></ul></div></div><div id=outline-container-headline-8 class=outline-4><h4 id=headline-8>Floating-Point Types</h4><div id=outline-text-headline-8 class=outline-text-4><ul><li><p>There are <code class=verbatim>f32</code> or <code class=verbatim>f64</code> in Rust. There is no double.</p></li><li><p>Default type is <code class=verbatim>f64</code>.</p></li></ul></div></div><div id=outline-container-headline-9 class=outline-4><h4 id=headline-9>Numeric Operations</h4><div id=outline-text-headline-9 class=outline-text-4><ul><li><p>Division behaves in the same way as <code class=verbatim>C</code>.</p></li></ul></div></div><div id=outline-container-headline-10 class=outline-4><h4 id=headline-10>Boolean Type</h4><div id=outline-text-headline-10 class=outline-text-4><ul><li><p>Type <code class=verbatim>bool</code> has too possible values, <code class=verbatim>true</code> or <code class=verbatim>false</code>.</p></li></ul></div></div><div id=outline-container-headline-11 class=outline-4><h4 id=headline-11>Character Type</h4><div id=outline-text-headline-11 class=outline-text-4><ul><li><p>Size of 4 bytes</p></li><li><p>Represents a Unicode Scalar Value.</p></li></ul></div></div><div id=outline-container-headline-12 class=outline-4><h4 id=headline-12>Compound Types</h4><div id=outline-text-headline-12 class=outline-text-4><dl><dt>compound types</dt><dd><p>Can group multiple values into one type.</p></dd></dl></div></div><div id=outline-container-headline-13 class=outline-4><h4 id=headline-13>Tuple Type</h4><div id=outline-text-headline-13 class=outline-text-4><ul><li><p>Create a tuple by writing a comma-separated list of values inside parentheses.</p></li><li><p>Each position in the parentheses has a type.</p></li><li><p>These types do not have to be the same.</p></li></ul><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> tup: (<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>f32</span>, <span style=color:#66d9ef>i8</span>) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>6.4</span>, <span style=color:#ae81ff>1</span>);
    <span style=color:#66d9ef>let</span> (x, y, z) <span style=color:#f92672>=</span> tup;
    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;The value of y is {}&#34;</span>, y);
}</code></pre></div></div><ul><li><p>One way to access a value inside a tuple is destructuring through pattern matching.</p></li><li><p>Another way to access a value is using <code class=verbatim>.</code> with an index. The first element in the tuple is indexed 0.</p></li></ul><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> tup: (<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>f32</span>, <span style=color:#66d9ef>i8</span>) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>6.4</span>, <span style=color:#ae81ff>1</span>)
    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;The value of y is {}&#34;</span>, tup.<span style=color:#ae81ff>1</span>);
}</code></pre></div></div></div></div><div id=outline-container-headline-14 class=outline-4><h4 id=headline-14>Array Type</h4><div id=outline-text-headline-14 class=outline-text-4><ul><li><p>Each element in an array must has the same type.</p></li><li><p>Arrays in rust have fixed length.</p></li><li><p>Arrays are allocated on stack.</p></li><li><p>Type on an array is a composition of its elements' type and its length.</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> a: [<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];</code></pre></div></div></li><li><p>An array can be initialized in the following way if each element has the same value.</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>4</span>; <span style=color:#ae81ff>8</span>]; <span style=color:#75715e>// 8 elements, each element has a value of 4.
</span></code></pre></div></div></li></ul><div id=outline-container-headline-15 class=outline-5><h5 id=headline-15>Accessing Array Element</h5><div id=outline-text-headline-15 class=outline-text-5><ul><li><p>Element can be accessed using indexing.</p></li><li><p>Rust will check if an index is in the bound in runtime.</p></li></ul></div></div></div></div></div></div><div id=outline-container-headline-16 class=outline-3><h3 id=headline-16>Functions</h3><div id=outline-text-headline-16 class=outline-text-3><ul><li><p><code class=verbatim>fn</code> allows you to declare a new function.</p></li><li><p>Functions can be defined anywhere in the source code.</p></li><li><p>Parameters of a function must have types declared.</p></li><li><p>Instructions that perform some action and do not return a value are <code class=verbatim>statements</code>.</p></li><li><p><code class=verbatim>Expressions</code> Evaluate to a resulting value.</p></li><li><p>Expressions can be part of statements.</p></li><li><p>Function bodies are made up of a series of statements optionally ending in an expression.</p></li><li><p>Calling a function is an expression.</p></li><li><p>The block that we use to create new scopes, <code class=verbatim>{}</code>, is an expression.</p></li><li><p>Expressions do not include ending semicolons.</p></li></ul><div id=outline-container-headline-17 class=outline-5><h5 id=headline-17>Functions with Return Values</h5><div id=outline-text-headline-17 class=outline-text-5><ul><li><p>Declare return value's type using <code class=verbatim>-></code>.</p></li><li><p>The return value of the function is synonymous with the value of the final expression in the block of the body of a function.</p></li><li><p>To return early, use <code class=verbatim>return</code>.</p></li></ul></div></div></div></div><div id=outline-container-headline-18 class=outline-3><h3 id=headline-18>Control Flow</h3><div id=outline-text-headline-18 class=outline-text-3><ul><li><p>Unlike <code class=verbatim>C</code>, the condition must be a <code class=verbatim>bool</code>.</p></li></ul><div id=outline-container-headline-19 class=outline-4><h4 id=headline-19>If</h4><div id=outline-text-headline-19 class=outline-text-4><ul><li><p><code class=verbatim>if</code> is an expression, so it can be used on the right side of a <code class=verbatim>let</code> statement.</p></li><li><p>All arms must have the same type.</p></li></ul></div></div><div id=outline-container-headline-20 class=outline-4><h4 id=headline-20>Repetition</h4><div id=outline-text-headline-20 class=outline-text-4><div id=outline-container-headline-21 class=outline-5><h5 id=headline-21>Loop</h5><div id=outline-text-headline-21 class=outline-text-5><ul><li><p>The loop keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop by using the keyword <code class=verbatim>break</code>.</p></li><li><p>Value after the <code class=verbatim>break</code> expression will be return.</p></li></ul></div></div><div id=outline-container-headline-22 class=outline-5><h5 id=headline-22>For</h5><div id=outline-text-headline-22 class=outline-text-5><ul><li><p>For each loop on collection</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> numbers <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
<span style=color:#66d9ef>for</span> number <span style=color:#66d9ef>in</span> numbers.iter() {
    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;{}&#34;</span>, number);
}</code></pre></div></div></li><li><p>For each loop on range</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>1</span>..<span style=color:#ae81ff>4</span>).rev() {
    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;{}&#34;</span>, i);
}</code></pre></div></div></li></ul></div></div></div></div></div></div></div></div><div id=outline-container-headline-23 class=outline-2><h2 id=headline-23>Using Structs to Structure Related Data</h2><div id=outline-text-headline-23 class=outline-text-2><div id=outline-container-headline-24 class=outline-3><h3 id=headline-24>Defining and Instantiating Structs</h3><div id=outline-text-headline-24 class=outline-text-3><ul><li><p>Using dot notation, <code class=verbatim>.</code>, to get a specific value from a struct.</p></li><li><p>A filed of an immutable struct cannot be modified.</p></li><li><p>If a struct is mutable, the dot notation can both access and modify fields of that struct.</p></li><li><p>Cannot make certain field of a struct mutable.</p></li><li><p>If variable that initialize a field has the same name as the field, no need to repeat the name.</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>build_user</span>(email: String, username: String) -&gt; <span style=color:#a6e22e>User</span> {
    User {
        email,
        username,
        active: <span style=color:#a6e22e>true</span>,
        sign_in_count: <span style=color:#ae81ff>1</span>,
}
}</code></pre></div></div></li><li><p>When creating a new struct instance with some fields from an old instance, use <code class=verbatim>..</code> specifies that the remaining fields have the same values as the fields in the given instance.</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> user2 <span style=color:#f92672>=</span> User {
    email: String::from(<span style=color:#e6db74>&#34;another@example.com&#34;</span>),
    username: String::from(<span style=color:#e6db74>&#34;anotherusername567&#34;</span>),
..user1
};</code></pre></div></div></li><li><p>Tuple struct does not provide names associated with its fields but types.</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Color</span>(<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>);
<span style=color:#66d9ef>let</span> black <span style=color:#f92672>=</span> Color(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);</code></pre></div></div></li></ul></div></div><div id=outline-container-headline-25 class=outline-3><h3 id=headline-25>Method Syntax</h3><div id=outline-text-headline-25 class=outline-text-3><ul><li><p>The first parameter for a method is always <code class=verbatim>self</code>.</p></li><li><p>Methods can also take ownership, like functions.</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Rectangle</span> {
    width: <span style=color:#66d9ef>u32</span>,
height: <span style=color:#66d9ef>u32</span>,
}

<span style=color:#66d9ef>impl</span> Rectangle {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>area</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>u32</span> {
 self.width <span style=color:#f92672>*</span> self.height
}
}</code></pre></div></div></li><li><p>If a method inside <code class=verbatim>impl</code> block does not have <code class=verbatim>self</code> as its first parameter, then this method is considered as <code class=verbatim>associated function</code>.</p></li><li><p>Associated functions can be called by <code class=verbatim>::</code> syntax.</p></li><li><p>Each struct can have multiple <code class=verbatim>impl</code> blocks.</p></li></ul></div></div></div></div><div id=outline-container-headline-26 class=outline-2><h2 id=headline-26>Understanding Ownership</h2><div id=outline-text-headline-26 class=outline-text-2><div id=outline-container-headline-27 class=outline-3><h3 id=headline-27>What is Ownership?</h3><div id=outline-text-headline-27 class=outline-text-3><ul><li><p>All data stored on the stack must have a known, fixed size.</p></li><li><p>Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p></li><li><p>Ownership Rules</p><ul><li><p>Each value in Rust has a variable that's called it s owner.</p></li><li><p>There can only be one owner at a time.</p></li><li><p>When the owner goes out of scope, the value will be dropped.</p></li></ul></li><li><p>In Rust, the memory is automatically returned once the variable that owns it goes out of scope.</p></li><li><p>Rust calls <code class=verbatim>drop</code> automatically at the closing curly bracket where the variable will go out of scope.</p></li><li><p>Only copying those on the stack and pointers, which are also on the stack, to the heap, but not data on the heap.</p></li><li><p>This sounds like shallow copy, but rust invalid the variable being copied. That is, old variable cannot be read or wrote anymore.</p></li><li><p>This is known as move.</p></li><li><p>Copying everything on the heap is very expensive.</p></li><li><p>rust will never automatically create "deep" copies of your data.</p></li><li><p>Use common method <code class=verbatim>clone</code> to create a "deep" copy.</p></li></ul><div id=outline-container-headline-28 class=outline-4><h4 id=headline-28>Ownership and Functions</h4><div id=outline-text-headline-28 class=outline-text-4><ul><li><p>The semantics for passing a value to a function are similar to those for assigning a value to a variable.</p></li><li><p>When a value passes into a function, the ownership also is passed into the function.</p></li><li><p>Returning a value can also pass ownership.</p></li></ul></div></div></div></div><div id=outline-container-headline-29 class=outline-3><h3 id=headline-29>References and Borrowing</h3><div id=outline-text-headline-29 class=outline-text-3><ul><li><p>Reference allows you to refer to some value without taking ownership of it.</p></li><li><p>The <code class=verbatim>&val</code> syntax lets us create a reference that refers to the value <code class=verbatim>val</code> but does not own it.</p></li><li><p>We don't drop what the reference points to when the reference goes out of scope because we don't have ownership.</p></li><li><p>References are immutable by default.</p></li><li><p>You can have only one mutable reference to a particular piece of data in a particular scope.</p></li><li><p>We also cannot have a mutable reference while we have an immutable one.</p></li><li><p>The scope of a reference starts from where it is introduces and continues through the last time that reference is used.</p></li><li><p>The Rules of References:</p><ol><li><p>At any given time, you can have either one mutable reference or any number of immutable references.</p></li><li><p>References must always be valid.</p></li></ol></li></ul></div></div></div></div><div id=outline-container-headline-30 class=outline-2><h2 id=headline-30>Enums and Pattern Matching</h2><div id=outline-text-headline-30 class=outline-text-2><div id=outline-container-headline-31 class=outline-3><h3 id=headline-31>Defining an Enum</h3><div id=outline-text-headline-31 class=outline-text-3><ul><li><p>Enums can have different types.</p></li><li><p>Enums is similar to algebraic data types in functional programming languages.</p></li><li><p>Enums can have methods using <code class=verbatim>impl</code>.</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Message</span> {
    Quit,
Move { x: <span style=color:#66d9ef>i32</span>, y: <span style=color:#66d9ef>i32</span> },
Write(String),
ChangeColor(<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>),
HiTuple((<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>)),
}

<span style=color:#66d9ef>impl</span> Message {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>call</span>(<span style=color:#f92672>&amp;</span>self) {
        println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Hello Message&#34;</span>);
    }
}</code></pre></div></div></li></ul><div id=outline-container-headline-32 class=outline-4><h4 id=headline-32>The <code class=verbatim>Option</code> Enum</h4><div id=outline-text-headline-32 class=outline-text-4><ul><li><p><code class=verbatim>Option&lt;T></code> is provided by Rust, included in prelude.</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>enum</span> Option<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    Some(T),
    None,
}</code></pre></div></div></li><li><p>Value of <code class=verbatim>Option&lt;T></code> typed cannot be used in place of value typed <code class=verbatim>&lt;T></code>.</p></li></ul></div></div></div></div><div id=outline-container-headline-33 class=outline-3><h3 id=headline-33>The <code class=verbatim>match</code> Control Flow Operator</h3><div id=outline-text-headline-33 class=outline-text-3><ul><li><p><code class=verbatim>=></code> separates the pattern and the code to run.</p></li><li><p>You can use curly braces if there are multiple lines of code to run after pattern-matched.</p></li><li><p>We must exhaust every last possibility in order for the code to be valid.</p></li><li><p><code class=verbatim>_</code> will match any value</p></li></ul></div></div><div id=outline-container-headline-34 class=outline-3><h3 id=headline-34>Concise Control flow with <code class=verbatim>if let</code></h3><div id=outline-text-headline-34 class=outline-text-3><ul><li><p><code class=verbatim>if let</code> matches one pattern.</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(<span style=color:#ae81ff>3</span>) <span style=color:#f92672>=</span> some_u8_value {
    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;three&#34;</span>);
}</code></pre></div></div></li><li><p>Compiler does not check if cases are exhaustive.</p></li><li><p>Can be used with a <code class=verbatim>else</code> statement.</p></li></ul></div></div></div></div><div id=outline-container-headline-35 class=outline-2><h2 id=headline-35>Common Collections</h2><div id=outline-text-headline-35 class=outline-text-2><div id=outline-container-headline-36 class=outline-3><h3 id=headline-36>Vector</h3><div id=outline-text-headline-36 class=outline-text-3><ul><li><p>Can only store values of the same type</p></li><li><p>When a vector gets dropped, all of its contents are also dropped.</p></li><li><p>Vectors are indexed by number, starting at zero.</p></li><li><p>Adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space.</p></li></ul></div></div><div id=outline-container-headline-37 class=outline-3><h3 id=headline-37>String</h3><div id=outline-text-headline-37 class=outline-text-3><ul><li><p>The compiler can coerce the <code class=verbatim>&String</code> argument into a <code class=verbatim>&str</code>.</p></li><li><p>Using <code class=verbatim>+</code> to concatenate two strings <code class=verbatim>s1</code> and <code class=verbatim>s2</code>, <code class=verbatim>let s3 = s1 + &s2</code>, actually takes ownership of s1, appends a copy of the contents of s2, and then returns ownership of the result.</p></li><li><p>Rust strings don't support indexing.</p></li></ul></div></div><div id=outline-container-headline-38 class=outline-3><h3 id=headline-38>Hash Map</h3><div id=outline-text-headline-38 class=outline-text-3><ul><li><p>The type <code class=verbatim>HashMap&lt;K, V></code> stores a mapping of keys of type <code class=verbatim>K</code> to values of type <code class=verbatim>V</code>.</p></li><li><p>We need to first <code class=verbatim>use</code> the <code class=verbatim>HashMap</code> form the collections portion of the standard library.</p></li><li><p>All of keys must have the same type, and all of the values must have the same type.</p></li><li><p>One can use <code class=verbatim>collect</code> method to turn a vector of tuples into a hash map.</p></li><li><p>Types that implement the <code class=verbatim>Copy</code> trait are copied into the hash map.</p></li><li><p>Owned values are moved and the hash map will be the owner of those values.</p></li><li><p>Inserting references to values into the hasp map does not move the value into the hash map.</p></li><li><p><code class=verbatim>get()</code> returns an <code class=verbatim>Option&lt;&V></code>.</p></li><li><p>Insert a inserted key with different value will replace the old value.</p></li><li><p>Use <code class=verbatim>entry()</code> and <code class=verbatim>or_insert()</code> to insert a value if the key does not appear in the hash map.</p></li><li><p><code class=verbatim>or_insert()</code> returns a reference to the value associates to the key.</p></li><li><p>Can dereference the return value of <code class=verbatim>or_insert()</code> to update the value.</p></li></ul></div></div></div></div><div id=outline-container-headline-39 class=outline-2><h2 id=headline-39>Error Handling</h2><div id=outline-text-headline-39 class=outline-text-2><div id=outline-container-headline-40 class=outline-3><h3 id=headline-40>Unrecoverable Errors with <code class=verbatim>panic!</code></h3><div id=outline-text-headline-40 class=outline-text-3><ul><li><p>When the <code class=verbatim>panic!</code> macro executes, the program will print a failure message, unwind and clean up the stack, and then quit.</p></li><li><p>Set <code class=verbatim>RUST_BACKTRACE=1</code> to display the backtrace.</p></li></ul></div></div><div id=outline-container-headline-41 class=outline-3><h3 id=headline-41>Recoverable Errors with <code class=verbatim>Result</code></h3><div id=outline-text-headline-41 class=outline-text-3><ul><li><p>Use <code class=verbatim>unwrap()</code> method on <code class=verbatim>Result</code> type. If the value is <code class=verbatim>Ok</code> variant, <code class=verbatim>unwrap</code> will return the value inside the <code class=verbatim>Ok</code>. If the <code class=verbatim>Result</code> is the <code class=verbatim>Err</code> variant, <code class=verbatim>unwrap</code> will call the <code class=verbatim>panic!</code> macro for us.</p></li><li><p><code class=verbatim>expect()</code> is similar to <code class=verbatim>unwrap()</code>, but more detailed error message can be provided.</p></li><li><p>The <code class=verbatim>?</code> operator can be used in Functions that return <code class=verbatim>Result</code>.</p></li></ul></div></div></div></div><div id=outline-container-headline-42 class=outline-2><h2 id=headline-42>Traits, and Lifetimes</h2><div id=outline-text-headline-42 class=outline-text-2><div id=outline-container-headline-43 class=outline-3><h3 id=headline-43>Traits: Defining Shared Behavior</h3><div id=outline-text-headline-43 class=outline-text-3><ul><li><p>A trait tells the Rust compiler about functionality a particular types has can share with other types.</p></li><li><p>When implementing a trait, put the trait name after <code class=verbatim>impl</code> and then use the <code class=verbatim>for</code> keyword and specify the name of the type we want to implement the trait for.</p></li><li><p><code class=verbatim>pub</code> makes a trait public so that other crates are able to implement it.</p></li><li><p>We can implement a trait on a type only if either the trait or the type is local to our crate.</p></li><li><p>To use a default implementation, specify and empty <code class=verbatim>impl</code> block.</p></li><li><p><code class=verbatim>impl</code> can also be used on type parameter.</p></li><li><p><code class=verbatim>+</code> syntax to specify multiple trait bounds.</p></li><li><p><code class=verbatim>where</code> clause allows clearer trait bounds.</p></li><li><p><code class=verbatim>impl Trait</code> syntax can also be used in the return position, but this function should only return a single type.</p></li><li><p>Rust allows conditionally implement a trait.</p></li></ul></div></div><div id=outline-container-headline-44 class=outline-3><h3 id=headline-44>Validating References with Lifetimes</h3><div id=outline-text-headline-44 class=outline-text-3><p>Every reference in Rust has a lifetime.</p><ul><li><p>Lifetimes prevent dangling references.</p></li><li><p>The names of lifetime parameters must start with an apostrophe (<code class=verbatim>'</code>).</p></li><li><p>We place lifetime parameter annotations after the <code class=verbatim>&</code> of a reference.</p></li><li><p>When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters.</p></li><li><p>Lifetimes syntax is about connecting the lifetimes of various parameters and return values of functions.</p></li><li><p>Lifetime Elision Rules</p><ul><li><p>Each parameter that is a reference gets its own lifetime.</p></li><li><p>If there is exactly one input lifetime parameter, that lifetime is assigned to all.</p></li><li><p>If there are multiple input lifetime parameters, but one of them is <code class=verbatim>&self</code> or <code class=verbatim>&mut self</code> because this is a method, the lifetime of <code class=verbatim>self</code> is assigned to all output lifetime parameters.</p></li></ul><p>-<code class=verbatim>'static</code> means that this reference can live for the entire duration of the program.</p></li></ul></div></div></div></div><div class=footnotes><hr class=footnotes-separatator><div class=footnote-definitions><div class=footnote-definition><sup id=footnote-1><a href=#footnote-reference-1>1</a></sup><div class=footnote-body><p>Notes from The Rust Programming Language</p></div></div></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.mrr1vfe.io/tags/rust/>Rust</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Notes on The Rust Programming Language on twitter" href="https://twitter.com/intent/tweet/?text=Notes%20on%20The%20Rust%20Programming%20Language&url=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2ftrpl%2f&hashtags=Rust"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Notes on The Rust Programming Language on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2ftrpl%2f&title=Notes%20on%20The%20Rust%20Programming%20Language&summary=Notes%20on%20The%20Rust%20Programming%20Language&source=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2ftrpl%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Notes on The Rust Programming Language on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2ftrpl%2f&title=Notes%20on%20The%20Rust%20Programming%20Language"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Notes on The Rust Programming Language on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2ftrpl%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Notes on The Rust Programming Language on whatsapp" href="https://api.whatsapp.com/send?text=Notes%20on%20The%20Rust%20Programming%20Language%20-%20https%3a%2f%2fwww.mrr1vfe.io%2fposts%2ftrpl%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Notes on The Rust Programming Language on telegram" href="https://telegram.me/share/url?text=Notes%20on%20The%20Rust%20Programming%20Language&url=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2ftrpl%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://www.mrr1vfe.io/>mrr1vfe</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>