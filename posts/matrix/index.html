<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Compiling C code using GCC | mrr1vfe</title><meta name=keywords content="C,Cache,Optimization"><meta name=description content="Basic compilation using GCC  gcc matrix.c  This command outputs a executable binary named a.out, which can be executed in the shell by ./a.out.
  Name the output binary file  a.out may not be a great name for the your binary, and using mv to rename a file every time after compilation is tedious. The -o flag allows users to name the output binary.
gcc matrix.c -o matrix  Run the program by ."><meta name=author content="Reid Chen"><link rel=canonical href=https://www.mrr1vfe.io/posts/matrix/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.mrr1vfe.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.mrr1vfe.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.mrr1vfe.io/favicon-32x32.png><link rel=apple-touch-icon href=https://www.mrr1vfe.io/apple-touch-icon.png><link rel=mask-icon href=https://www.mrr1vfe.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.0"><meta property="og:title" content="Compiling C code using GCC"><meta property="og:description" content="Basic compilation using GCC  gcc matrix.c  This command outputs a executable binary named a.out, which can be executed in the shell by ./a.out.
  Name the output binary file  a.out may not be a great name for the your binary, and using mv to rename a file every time after compilation is tedious. The -o flag allows users to name the output binary.
gcc matrix.c -o matrix  Run the program by ."><meta property="og:type" content="article"><meta property="og:url" content="https://www.mrr1vfe.io/posts/matrix/"><meta property="og:image" content="https://www.mrr1vfe.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-08-17T00:00:00+00:00"><meta property="article:modified_time" content="2020-08-17T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.mrr1vfe.io/papermod-cover.png"><meta name=twitter:title content="Compiling C code using GCC"><meta name=twitter:description content="Basic compilation using GCC  gcc matrix.c  This command outputs a executable binary named a.out, which can be executed in the shell by ./a.out.
  Name the output binary file  a.out may not be a great name for the your binary, and using mv to rename a file every time after compilation is tedious. The -o flag allows users to name the output binary.
gcc matrix.c -o matrix  Run the program by ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.mrr1vfe.io/posts/"},{"@type":"ListItem","position":2,"name":"Compiling C code using GCC","item":"https://www.mrr1vfe.io/posts/matrix/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Compiling C code using GCC","name":"Compiling C code using GCC","description":"Basic compilation using GCC  gcc matrix.c  This command outputs a executable binary named a.out, which can be executed in the shell by ./a.out.\n  Name the output binary file  a.out may not be a great name for the your binary, and using mv to rename a file every time after compilation is tedious. The -o flag allows users to name the output binary.\ngcc matrix.c -o matrix  Run the program by .","keywords":["C","Cache","Optimization"],"articleBody":" Basic compilation using GCC  gcc matrix.c  This command outputs a executable binary named a.out, which can be executed in the shell by ./a.out.\n  Name the output binary file  a.out may not be a great name for the your binary, and using mv to rename a file every time after compilation is tedious. The -o flag allows users to name the output binary.\ngcc matrix.c -o matrix  Run the program by ./matrix.\n  Four Steps of compiling a c file to a executable binary    Preprocessing\n  Compiling   Assembly\n  Linking\n  Preprocessing  First step of a compilation process in which header files are swapped in, macros are substituted with its actual value, and conditional compilation is handled. The module which does the preprocessing is called preprocessor (cpp) whose input is a c file and output is a also a c file. To see the output of preprocessor, use the -E flag.\ngcc matrix.c -E -o matrix.i  matrix.i contains the preprocessed code.\n// original code #include #include  typedef struct matrix_container { int row; int col; int **matrix; } Matrix; // preprocessed code # 422 \"/usr/local/Cellar/gcc/10.1.0/lib/gcc/10/gcc/x86_64-apple-darwin19/10. 1.0/include-fixed/stdio.h\" 2 3 4# 3 \"matrix.c\" 2  # 4 \"matrix.c\" typedef struct matrix_container { int row; int col; int **matrix; } Matrix;  It can be seen that there is no more #include in the preprocessed file.\n  Compiling  Second step of a compilation process. The compiler (cc1) takes a preprocessed c file as an input and outputs a .s assembly program which contains the assembly code of the target machine. For example, my machine has an intel CPU. Therefore, the assembly program generated by the compiler (cc1) is in x86-64 instruction set. Adding the -m32 flag forces the compiler to generate IA-32 assembly code.\ngcc matrix.c -S -o matrix.s  output, content of matrix.s\nL1$pb: subl $12, %esp leal lC0-L1$pb(%ebx), %eax pushl %eax call _puts addl $16, %esp movl $0, -12(%ebp) jmp L2 L5: movl $0, -16(%ebp) jmp L3 L4: movl 8(%ebp), %eax    Assembling  The assemblar (as) converts the assembly program to the relocatable object program, which is a binary but non-executable file. The reason why the binary cannot be executed is that assembly code for functions like printf() that is not written by you is not included.\ngcc matrix.c -c -o matrix.o    Linking  The linker (ld) gathers all relocatable files and combines them into a single executable binary file. It takes relocatable object files as input and output the final executable binary. It can be seen that the output of linker is larger than the output of assemblar, which does not include binary of other relocatable object files. There is no special flag for the linker. matrix, the executable binary, is larger than matrix.o (13128  3772).\n-rwxr-xr-x 1 yichen 13128 Jul 30 23:32 matrix -rw-r--r-- 1 yichen 3772 Jul 31 02:49 matrix.o      Other flags  -Wall  Output all warnings. If I introduce a unused variable\nint main(void) { Matrix *matrices[2]; for (int i = 0; i  2; i++) matrices[i] = create_matrix(); Matrix *result = multiply_matrix(matrices[0], matrices[1]); print_matrix(result); Matrix *mat; // unused variable  free_matrix(result); free_matrix(matrices[0]); free_matrix(matrices[1]); return 0; }  compiling without -Wall flag, GCC does not have any output\n➜ matrix_hw gcc-10 matrix.c -o matrix ➜ matrix_hw  compiling with -Wall flag, GCC outputs a warning message\n➜ matrix_hw gcc-10 matrix.c -o matrix -Wall matrix.c: In function 'main': matrix.c:106:13: warning: unused variable 'mat' [-Wunused-variable] 106 | Matrix *mat; | ^~~    -D  -D [marco name]=[marco value] is equivalent to adding #define [marco name]=[macro value] to the source code.\nint main(void) { Matrix *matrices[SIZE]; for (int i = 0; i  SIZE; i++) matrices[i] = create_matrix(); Matrix *result = multiply_matrix(matrices[0], matrices[1]); print_matrix(result); free_matrix(result); free_matrix(matrices[0]); free_matrix(matrices[1]); return 0; }  The source code does not define SIZE. Hence, compiling without -D flag results an error.\nmatrix.c: In function 'main': matrix.c:99:22: error: 'SIZE' undeclared (first use in this function) 99 | Matrix *matrices[SIZE]; | ^~~~ matrix.c:99:22: note: each undeclared identifier is reported only once for each function it appears in  Using the -D flag.\ngcc-10 matrix.c -o matrix -D SIZE=2    -I  -I [dir] adding extra header directory. GCC finds header files in the current directory or in usr/include/. Compiling the source code that includes header file that is in other directory results an error.\n#include \"matrix_op.h\"#define SIZE 2  int main(void) { Matrix *matrices[SIZE]; for (int i = 0; i  SIZE; i++) matrices[i] = create_matrix(); Matrix *result = multiply_matrix(matrices[0], matrices[1]); print_matrix(result); free_matrix(result); free_matrix(matrices[0]); free_matrix(matrices[1]); return 0; }  matrix_op.h is not in . nor usr/include. It is in ./include.\n➜ matrix_hw ls include matrix matrix.c ➜ matrix_hw ls include matrix_op.h  Compile the code results an error.\n➜ matrix_hw gcc-10 matrix.c matrix_op.c -o matrix matrix.c:1:10: fatal error: matrix_op.h: No such file or directory 1 | #include \"matrix_op.h\" | ^~~~~~~~~~~~~ compilation terminated. matrix_op.c:3:10: fatal error: matrix_op.h: No such file or directory 3 | #include \"matrix_op.h\" | ^~~~~~~~~~~~~ compilation terminated.  To compile it, add -I [header dir].\nmatrix_hw gcc-10 matrix.c matrix_op.c -o matrix -I./include    -g  With -g, GCC compiles code with debug information, which is helpful when using debugger like GDB or LLDB. Setting breakpoints using filename and line number in LLDB, with binary that compiled without -g flag.\n(lldb) b matrix.c:9 Breakpoint 1: no locations (pending). WARNING: Unable to resolve breakpoint to any actual locations.  Setting breakpoints using filename and line number in LLDB, with binary that compiled with -g flag.\n(lldb) b matrix.c:9 Breakpoint 1: where = matrix`main + 48 at matrix.c:9:22, address = 0x0000000100000724  It is more easier to debug, setting breakpoints, for example, with binary that compiled with -g flag.\n    Optimization  To see the optimization results, I wrote a program that does matrix multiplication of different size of matrices. Each run of the program is going to output the time it takes to finish the job. Then, I use a python script to run the program for 100 times, and calculate the mean, standard deviation, and total time. Since $N = 100$ is greater than 30, the sampling distribution is normal.\n   Flag Average time (sec) Standard Deviation Compilation Time     None 0.55726 0.035869 0.195   -O 0.200644 0.006497 0.212   -O2 0.079052 0.002817 0.286   -O3 0.077760 0.003685 0.477    It can be seen that program compiled with -O flag is running significantly faster than program compiled without optimization flag. And program compiled with -O2 is running significantly faster than program compiled with -O1 flag. Moreover, the compilation time increases as more optimizations are applied.\nSignificance test on the running time difference between the program compiled with -O2 and -O3  Test at $\\alpha = 0.01$ \\begin{align*} H_0: μ_1 = μ_2 H_1: μ_1  μ_2 \\end{align*} where $\\mu_1$ is the true mean of running time of program compiled with -O2 flag and $\\mu_2$ is the true mean of running time of program compiled with -O3 flag.\n \\begin{align*} z \u0026= \\frac{\\bar{x_1} - \\bar{x_2}}{\\sqrt{\\frac{σ^2_1}{n_1} + \\frac{σ^2_2}{n_2}}}\n\u0026= \\frac{0.079052 - 0.077760}{\\sqrt{\\frac{0.002817^2}{100} + \\frac{0.003685^2}{100}}} \u0026=\t\\frac{0.001292}{0.000464} \u0026= 2.78 \\end{align*} Since $z = 2.78$ is greater than 2.575, we reject the $H_0$. There is enough evidence showing that the matrix program compiled with -O3 flag has significant shorter running time than the program compiled with -O2 flag.\n  Code, Script, and Results  Test code:\nstruct timeval tic, toc; gettimeofday(\u0026tic, NULL); for (int i = 0; i  100; i++) { Matrix *A = dummy_matrix(i, i * 5); Matrix *B = dummy_matrix(i * 5, i); multiply_matrix(A, B); free_matrix(A); free_matrix(B); } gettimeofday(\u0026toc, NULL); printf(\"%lu\", (toc.tv_sec - tic.tv_sec) * 1000000 + toc.tv_usec - tic.tv_usec);  Test script:\nimport os import math import subprocess N = 100 results = [] for i in range(0, N): result = subprocess.check_output('./matrix', shell=True) result = int(result) / 1000000 results.append(result) TOTAL = sum(results) MEAN = TOTAL / N def process(x): return (x - MEAN) ** 2 VAR = sum(list(map(process, results))) / N SD = math.sqrt(VAR) print(\"-\" * 10, \"Result\", \"-\" * 10) print(\"n = %d, sum = %f\" % (N, TOTAL)) print(\"mean = %f\" % MEAN) print(\"standard deviation = %f\" % SD) print(results)  Result without optimization flag\n---------- Result ---------- n = 100, sum = 55.726015 mean = 0.557260 standard deviation = 0.035869  Result with -O flag\n---------- Result ---------- n = 100, sum = 20.064405 mean = 0.200644 standard deviation = 0.006497  Result with -O2 flag\n---------- Result ---------- n = 100, sum = 7.905217 mean = 0.079052 standard deviation = 0.002817  Result with -O3 flag\n---------- Result ---------- n = 100, sum = 7.776048 mean = 0.077760 standard deviation = 0.003685      Different ways of performing matrix multiplication  1\njki  for (int j = 0; j  B-col; j++) { for (int k = 0; k  B-row; k++) { int r = B-matrix[k][j]; for (int i = 0; i  A-row; i++) { C-matrix[i][j] += A-matrix[i][k] * r; } } }  This program has the worst performance since it has the worst spatial locality. Suppose the cache can only hold a row of the matrix. Each inner iteration of the innermost loop would lead to a cache miss since; each iteration of the second-most-inner loop too would lead to a cache miss. A cache miss requires CPU to fetch data from memory via bus, which is time consuming comparing to using cache data.\n  kij  for (int k = 0; k  A-col; k++) { for (int i = 0; i  C-row; i++) { int r = A-matrix[i][k]; for (int j = 0; j  B-col; j++) { C-matrix[i][j] += r * B-matrix[k][j]; } } }  This way of performing matrix multiplication has the best performance since the stride size is smaller and the program takes the advantages of both spatial and temporal locality.\n  ijk  for (int i = 0; i  C-row; i++) { for (int j = 0; j  C-col; j++) { for (int k = 0; k  A-col; k++) { C-matrix[i][j] += A-matrix[i][k] * B-matrix[k][j]; } } }  This program has the moderate performance.   Comparison  Here is a plot comparing the average task completion time of 50 runs of each ways of performing matrix multiplication. It can be seen that generally, kij has the best performance. It advantage is especially notable when the dimension of matrix is increasing, as more L1 cache is used.     Different optimization flags on different sizes of matrix  The plot indicates that -03 has the best performance over all the other optimization rules. As the dimension of the matrix involved in the multiplication process increases, the advantage of -O3 is more noticeable. The reason that -O3 has the best performance is that -O3 attempts to vectorize loops, which are used abundantly in the operation of matrix multiplication. It uses more advanced instruction set that has better arithmetic performance. It can be seen from the following image that -O2 flag together with ftree-vectorize achieve the similar performance of -O3. This phenomenon indicates that vectorization has a great impact on program's performance. Moreover, according to GCC, line 112 is optimized.\n➜ code gcc-10 matrix_op.c main.c -o matrix_vec -ftree-vectorize -O2 -mavx -fopt-info-vec-optimized matrix_op.c:112:3: optimized: loop vectorized using 16 byte vectors matrix_op.c:112:3: optimized: loop versioned for vectorization because of possible aliasing  This line is corresponding to the following C code\nfor (int j = 0; j  B-col; j++)  Which is an essential part to the matrix multiplication.\n  -ftree-vectorize  As mentioned above, the most significant optimization in -O3 for the program is -ftree-vectorize. Roughly speaking, when -ftree-vectorize is activated, GCC will try to convert normal loop into loop that utilizes SIMD built-in functions. The tree-vectorizer is going to analyze the loops and then transform the vectorizable loops into the designated form. Each loop and each statement in will be attached by loop_vec_info and stmt_vec_info. When transforming loop, the program is going to scan every statements inside the loop and create a corresponding vector for everything needed to be vectorized.\n  1 https://blog.csdn.net/haolexiao/article/details/65936158\n    ","wordCount":"1939","inLanguage":"en","datePublished":"2020-08-17T00:00:00Z","dateModified":"2020-08-17T00:00:00Z","author":{"@type":"Person","name":"Reid Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.mrr1vfe.io/posts/matrix/"},"publisher":{"@type":"Organization","name":"mrr1vfe","logo":{"@type":"ImageObject","url":"https://www.mrr1vfe.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://www.mrr1vfe.io/ accesskey=h title="mrr1vfe (Alt + H)">mrr1vfe</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.mrr1vfe.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://www.mrr1vfe.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://www.mrr1vfe.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.mrr1vfe.io/series title=Series><span>Series</span></a></li><li><a href=https://www.mrr1vfe.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://archive.casouri.cat/ title=BHL0388><span>BHL0388</span></a></li><li><a href=https://archive.casouri.cat/goldfish/index.html title=金鱼><span>金鱼</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Compiling C code using GCC</h1><div class=post-meta>August 17, 2020&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Reid Chen</div></header><div class=post-content><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>Basic compilation using GCC</h2><div id=outline-text-headline-1 class=outline-text-2><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>gcc matrix.c</code></pre></div></div><p>This command outputs a executable binary named <code class=verbatim>a.out</code>, which can be executed in the shell by <code class=verbatim>./a.out</code>.</p></div></div><div id=outline-container-headline-2 class=outline-2><h2 id=headline-2>Name the output binary file</h2><div id=outline-text-headline-2 class=outline-text-2><p><code class=verbatim>a.out</code> may not be a great name for the your binary, and using <code class=verbatim>mv</code> to rename a file every time after compilation is tedious. The <code class=verbatim>-o</code> flag allows users to name the output binary.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>gcc matrix.c -o matrix</code></pre></div></div><p>Run the program by <code class=verbatim>./matrix</code>.</p></div></div><div id=outline-container-headline-3 class=outline-2><h2 id=headline-3>Four Steps of compiling a c file to a executable binary</h2><div id=outline-text-headline-3 class=outline-text-2><ol><li><p>Preprocessing</p></li><li><p>Compiling</p></li><li><p>Assembly</p></li><li><p>Linking</p></li></ol><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>Preprocessing</h3><div id=outline-text-headline-4 class=outline-text-3><p>First step of a compilation process in which <code class=verbatim>header</code> files are swapped in, <code class=verbatim>macros</code> are substituted with its actual value, and <code class=verbatim>conditional compilation</code> is handled.
The module which does the preprocessing is called preprocessor (<code class=verbatim>cpp</code>) whose input is a <code class=verbatim>c file</code> and output is a also a <code class=verbatim>c file</code>. To see the output of preprocessor, use the <code class=verbatim>-E</code> flag.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>gcc matrix.c -E -o matrix.i</code></pre></div></div><p><code class=verbatim>matrix.i</code> contains the preprocessed code.</p><div class="src src-c"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// original code
</span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> matrix_container {
    <span style=color:#66d9ef>int</span> row;
    <span style=color:#66d9ef>int</span> col;
    <span style=color:#66d9ef>int</span> <span style=color:#f92672>**</span>matrix;
} Matrix;
<span style=color:#75715e>// preprocessed code
</span><span style=color:#75715e></span><span style=color:#75715e># 422 &#34;/usr/local/Cellar/gcc/10.1.0/lib/gcc/10/gcc/x86_64-apple-darwin19/10. 1.0/include</span><span style=color:#75715e>-fixed/stdio.h&#34; 2 3 4</span><span style=color:#75715e>
</span><span style=color:#75715e># 3 &#34;matrix.c&#34; 2
</span><span style=color:#75715e></span>

<span style=color:#75715e># 4 &#34;matrix.c&#34;
</span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> matrix_container {
    <span style=color:#66d9ef>int</span> row;
    <span style=color:#66d9ef>int</span> col;
    <span style=color:#66d9ef>int</span> <span style=color:#f92672>**</span>matrix;
} Matrix;</code></pre></div></div><p>It can be seen that there is no more <code class=verbatim>#include</code> in the preprocessed file.</p></div></div><div id=outline-container-headline-5 class=outline-3><h3 id=headline-5>Compiling</h3><div id=outline-text-headline-5 class=outline-text-3><p>Second step of a compilation process. The <code class=verbatim>compiler</code> (<code class=verbatim>cc1</code>) takes a preprocessed c file as an input and outputs a <code class=verbatim>.s</code> assembly program which contains the assembly code of the target machine.
For example, my machine has an <code class=verbatim>intel</code> CPU. Therefore, the assembly program generated by the <code class=verbatim>compiler</code> (<code class=verbatim>cc1</code>) is in <code class=verbatim>x86-64</code> instruction set. Adding the <code class=verbatim>-m32</code> flag forces the compiler to generate <code class=verbatim>IA-32</code> assembly code.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>gcc matrix.c -S -o matrix.s</code></pre></div></div><p>output, content of matrix.s</p><div class="src src-x86-64"><pre><code class=language-x86-64 data-lang=x86-64>L1$pb:
  subl    $12, %esp
  leal    lC0-L1$pb(%ebx), %eax
  pushl   %eax
  call    _puts
  addl    $16, %esp
  movl    $0, -12(%ebp)
  jmp L2
L5:
  movl    $0, -16(%ebp)
  jmp L3
L4:
  movl    8(%ebp), %eax</code></pre></div></div></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>Assembling</h3><div id=outline-text-headline-6 class=outline-text-3><p>The <code class=verbatim>assemblar</code> (<code class=verbatim>as</code>) converts the assembly program to the relocatable object program, which is a binary but non-executable file. The reason why the binary cannot be executed is that assembly code for functions like <code class=verbatim>printf()</code> that is not written by you is not included.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>gcc matrix.c -c -o matrix.o</code></pre></div></div></div></div><div id=outline-container-headline-7 class=outline-3><h3 id=headline-7>Linking</h3><div id=outline-text-headline-7 class=outline-text-3><p>The <code class=verbatim>linker</code> (<code class=verbatim>ld</code>) gathers all relocatable files and combines them into a single executable binary file. It takes relocatable object files as input and output the final executable binary. It can be seen that the output of <code class=verbatim>linker</code> is larger than the output of <code class=verbatim>assemblar</code>, which does not include binary of other relocatable object files. There is no special flag for the <code class=verbatim>linker</code>.
<code class=verbatim>matrix</code>, the executable binary, is larger than <code class=verbatim>matrix.o</code> (13128 > 3772).</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>-rwxr-xr-x  1 yichen  13128 Jul 30 23:32 matrix
-rw-r--r--  1 yichen   3772 Jul 31 02:49 matrix.o</code></pre></div></div></div></div></div></div><div id=outline-container-headline-8 class=outline-2><h2 id=headline-8>Other flags</h2><div id=outline-text-headline-8 class=outline-text-2><div id=outline-container-headline-9 class=outline-3><h3 id=headline-9>-Wall</h3><div id=outline-text-headline-9 class=outline-text-3><p>Output all warnings. If I introduce a unused variable</p><div class="src src-c"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
     Matrix <span style=color:#f92672>*</span>matrices[<span style=color:#ae81ff>2</span>];
     <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>; i<span style=color:#f92672>++</span>)
         matrices[i] <span style=color:#f92672>=</span> create_matrix();
     
     Matrix <span style=color:#f92672>*</span>result <span style=color:#f92672>=</span> multiply_matrix(matrices[<span style=color:#ae81ff>0</span>], matrices[<span style=color:#ae81ff>1</span>]);
     print_matrix(result);

     Matrix <span style=color:#f92672>*</span>mat; <span style=color:#75715e>// unused variable
</span><span style=color:#75715e></span>
     free_matrix(result);
     free_matrix(matrices[<span style=color:#ae81ff>0</span>]);
     free_matrix(matrices[<span style=color:#ae81ff>1</span>]);
     <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
 }</code></pre></div></div><p>compiling without <code class=verbatim>-Wall</code> flag, <code class=verbatim>GCC</code> does not have any output</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>➜  matrix_hw gcc-10 matrix.c -o matrix
➜  matrix_hw</code></pre></div></div><p>compiling with <code class=verbatim>-Wall</code> flag, <code class=verbatim>GCC</code> outputs a warning message</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>➜  matrix_hw gcc-10 matrix.c -o matrix -Wall
matrix.c: In function &#39;main&#39;:
matrix.c:106:13: warning: unused variable &#39;mat&#39; [-Wunused-variable]
  106 |     Matrix *mat;
      |             ^~~</code></pre></div></div></div></div><div id=outline-container-headline-10 class=outline-3><h3 id=headline-10>-D</h3><div id=outline-text-headline-10 class=outline-text-3><p>-D [marco name]=[marco value] is equivalent to adding #define [marco name]=[macro value] to the source code.</p><div class="src src-c"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
 Matrix <span style=color:#f92672>*</span>matrices[SIZE];
 <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> SIZE; i<span style=color:#f92672>++</span>)
     matrices[i] <span style=color:#f92672>=</span> create_matrix();
 
 Matrix <span style=color:#f92672>*</span>result <span style=color:#f92672>=</span> multiply_matrix(matrices[<span style=color:#ae81ff>0</span>], matrices[<span style=color:#ae81ff>1</span>]);
 print_matrix(result);

 free_matrix(result);
 free_matrix(matrices[<span style=color:#ae81ff>0</span>]);
 free_matrix(matrices[<span style=color:#ae81ff>1</span>]);
 <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div></div><p>The source code does not define <code class=verbatim>SIZE</code>. Hence, compiling without <code class=verbatim>-D</code> flag results an error.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>matrix.c: In function &#39;main&#39;:
matrix.c:99:22: error: &#39;SIZE&#39; undeclared (first use in this function)
99 |     Matrix *matrices[SIZE];
   |                      ^~~~
matrix.c:99:22: note: each undeclared identifier is reported only once for each function it appears in</code></pre></div></div><p>Using the <code class=verbatim>-D</code> flag.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>gcc-10 matrix.c -o matrix -D SIZE=2</code></pre></div></div></div></div><div id=outline-container-headline-11 class=outline-3><h3 id=headline-11>-I</h3><div id=outline-text-headline-11 class=outline-text-3><p><code class=verbatim>-I [dir]</code> adding extra header directory. <code class=verbatim>GCC</code> finds header files in the current directory or in <code class=verbatim>usr/include/</code>. Compiling the source code that includes header file that is in other directory results an error.</p><div class="src src-c"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;matrix_op.h&#34;</span><span style=color:#75715e>
</span><span style=color:#75715e>#define SIZE 2
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
 Matrix <span style=color:#f92672>*</span>matrices[SIZE];
 <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> SIZE; i<span style=color:#f92672>++</span>)
     matrices[i] <span style=color:#f92672>=</span> create_matrix();
 
 Matrix <span style=color:#f92672>*</span>result <span style=color:#f92672>=</span> multiply_matrix(matrices[<span style=color:#ae81ff>0</span>], matrices[<span style=color:#ae81ff>1</span>]);
 print_matrix(result);

 free_matrix(result);
 free_matrix(matrices[<span style=color:#ae81ff>0</span>]);
 free_matrix(matrices[<span style=color:#ae81ff>1</span>]);
 <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div></div><p><code class=verbatim>matrix_op.h</code> is not in <code class=verbatim>.</code> nor <code class=verbatim>usr/include</code>. It is in <code class=verbatim>./include</code>.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>➜  matrix_hw ls
include     matrix      matrix.c
➜  matrix_hw ls include
matrix_op.h</code></pre></div></div><p>Compile the code results an error.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>➜  matrix_hw gcc-10 matrix.c matrix_op.c -o matrix
matrix.c:1:10: fatal error: matrix_op.h: No such file or directory
    1 | #include &#34;matrix_op.h&#34;
      |          ^~~~~~~~~~~~~
compilation terminated.
matrix_op.c:3:10: fatal error: matrix_op.h: No such file or directory
    3 | #include &#34;matrix_op.h&#34;
      |          ^~~~~~~~~~~~~
compilation terminated.</code></pre></div></div><p>To compile it, add <code class=verbatim>-I [header dir]</code>.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>matrix_hw gcc-10 matrix.c matrix_op.c -o matrix -I./include</code></pre></div></div></div></div><div id=outline-container-headline-12 class=outline-3><h3 id=headline-12>-g</h3><div id=outline-text-headline-12 class=outline-text-3><p>With <code class=verbatim>-g</code>, <code class=verbatim>GCC</code> compiles code with debug information, which is helpful when using debugger like <code class=verbatim>GDB</code> or <code class=verbatim>LLDB</code>.
Setting breakpoints using filename and line number in <code class=verbatim>LLDB</code>, with binary that compiled without <code class=verbatim>-g</code> flag.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>(lldb) b matrix.c:9
Breakpoint 1: no locations (pending).
WARNING:  Unable to resolve breakpoint to any actual locations.</code></pre></div></div><p>Setting breakpoints using filename and line number in <code class=verbatim>LLDB</code>, with binary that compiled with <code class=verbatim>-g</code> flag.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>(lldb) b matrix.c:9
Breakpoint 1: where = matrix`main + 48 at matrix.c:9:22, address = 0x0000000100000724</code></pre></div></div><p>It is more easier to debug, setting breakpoints, for example, with binary that compiled with <code class=verbatim>-g</code> flag.</p></div></div></div></div><div id=outline-container-headline-13 class=outline-2><h2 id=headline-13>Optimization</h2><div id=outline-text-headline-13 class=outline-text-2><p>To see the optimization results, I wrote a program that does matrix multiplication of different size of matrices. Each run of the program is going to output the time it takes to finish the job. Then, I use a python script to run the program for 100 times, and calculate the mean, standard deviation, and total time. Since $N = 100$ is greater than 30, the sampling distribution is normal.</p><table><thead><tr><th>Flag</th><th class=align-right>Average time (sec)</th><th class=align-right>Standard Deviation</th><th class=align-right>Compilation Time</th></tr></thead><tbody><tr><td>None</td><td class=align-right>0.55726</td><td class=align-right>0.035869</td><td class=align-right>0.195</td></tr><tr><td>-O</td><td class=align-right>0.200644</td><td class=align-right>0.006497</td><td class=align-right>0.212</td></tr><tr><td>-O2</td><td class=align-right>0.079052</td><td class=align-right>0.002817</td><td class=align-right>0.286</td></tr><tr><td>-O3</td><td class=align-right>0.077760</td><td class=align-right>0.003685</td><td class=align-right>0.477</td></tr></tbody></table><p>It can be seen that program compiled with <code class=verbatim>-O</code> flag is running significantly faster than program compiled without optimization flag.
And program compiled with <code class=verbatim>-O2</code> is running significantly faster than program compiled with <code class=verbatim>-O1</code> flag.
Moreover, the compilation time increases as more optimizations are applied.</p><div id=outline-container-headline-14 class=outline-3><h3 id=headline-14>Significance test on the running time difference between the program compiled with -O2 and -O3</h3><div id=outline-text-headline-14 class=outline-text-3><p>Test at $\alpha = 0.01$
\begin{align*}
H_0: μ_1 = μ_2<br>H_1: μ_1 > μ_2
\end{align*}
where $\mu_1$ is the true mean of running time of program compiled with <code class=verbatim>-O2</code> flag and $\mu_2$ is the true mean of running time of program compiled with <code class=verbatim>-O3</code> flag.</p><p>\begin{align*}
z &= \frac{\bar{x_1} - \bar{x_2}}{\sqrt{\frac{σ^2_1}{n_1} + \frac{σ^2_2}{n_2}}}<br>&= \frac{0.079052 - 0.077760}{\sqrt{\frac{0.002817^2}{100} + \frac{0.003685^2}{100}}}<br>&= \frac{0.001292}{0.000464}<br>&= 2.78
\end{align*}
Since $z = 2.78$ is greater than <code class=verbatim>2.575</code>, we reject the $H_0$. There is enough evidence showing that the matrix program compiled with <code class=verbatim>-O3</code> flag has significant shorter running time than the program compiled with <code class=verbatim>-O2</code> flag.</p></div></div><div id=outline-container-headline-15 class=outline-3><h3 id=headline-15>Code, Script, and Results</h3><div id=outline-text-headline-15 class=outline-text-3><p>Test code:</p><div class="src src-c"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>  <span style=color:#66d9ef>struct</span> timeval tic, toc;
  gettimeofday(<span style=color:#f92672>&amp;</span>tic, NULL);
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>100</span>; i<span style=color:#f92672>++</span>) {
Matrix <span style=color:#f92672>*</span>A <span style=color:#f92672>=</span> dummy_matrix(i, i <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>);
Matrix <span style=color:#f92672>*</span>B <span style=color:#f92672>=</span> dummy_matrix(i <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>, i);

multiply_matrix(A, B);

free_matrix(A);
free_matrix(B);
  }
  gettimeofday(<span style=color:#f92672>&amp;</span>toc, NULL);
  printf(<span style=color:#e6db74>&#34;%lu&#34;</span>, (toc.tv_sec <span style=color:#f92672>-</span> tic.tv_sec) <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000000</span> <span style=color:#f92672>+</span> toc.tv_usec <span style=color:#f92672>-</span> tic.tv_usec);</code></pre></div></div><p>Test script:</p><div class="src src-python"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> os
<span style=color:#f92672>import</span> math
<span style=color:#f92672>import</span> subprocess

N <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
results <span style=color:#f92672>=</span> []
<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, N):
  result <span style=color:#f92672>=</span> subprocess<span style=color:#f92672>.</span>check_output(<span style=color:#e6db74>&#39;./matrix&#39;</span>, shell<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
  result <span style=color:#f92672>=</span> int(result) <span style=color:#f92672>/</span> <span style=color:#ae81ff>1000000</span>
  results<span style=color:#f92672>.</span>append(result)

TOTAL <span style=color:#f92672>=</span> sum(results)
MEAN <span style=color:#f92672>=</span> TOTAL <span style=color:#f92672>/</span> N

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>process</span>(x):
  <span style=color:#66d9ef>return</span> (x <span style=color:#f92672>-</span> MEAN) <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span>
VAR <span style=color:#f92672>=</span> sum(list(map(process, results))) <span style=color:#f92672>/</span> N
SD <span style=color:#f92672>=</span> math<span style=color:#f92672>.</span>sqrt(VAR)


print(<span style=color:#e6db74>&#34;-&#34;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>, <span style=color:#e6db74>&#34;Result&#34;</span>, <span style=color:#e6db74>&#34;-&#34;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>)
print(<span style=color:#e6db74>&#34;n = </span><span style=color:#e6db74>%d</span><span style=color:#e6db74>, sum = </span><span style=color:#e6db74>%f</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> (N, TOTAL))
print(<span style=color:#e6db74>&#34;mean = </span><span style=color:#e6db74>%f</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> MEAN)
print(<span style=color:#e6db74>&#34;standard deviation = </span><span style=color:#e6db74>%f</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> SD)
print(results)</code></pre></div></div><p>Result without optimization flag</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>---------- Result ----------
n = 100, sum = 55.726015
mean = 0.557260
standard deviation = 0.035869</code></pre></div></div><p>Result with <code class=verbatim>-O</code> flag</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>---------- Result ----------
n = 100, sum = 20.064405
mean = 0.200644
standard deviation = 0.006497</code></pre></div></div><p>Result with <code class=verbatim>-O2</code> flag</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>---------- Result ----------
n = 100, sum = 7.905217
mean = 0.079052
standard deviation = 0.002817</code></pre></div></div><p>Result with <code class=verbatim>-O3</code> flag</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>---------- Result ----------
n = 100, sum = 7.776048
mean = 0.077760
standard deviation = 0.003685</code></pre></div></div></div></div></div></div><div id=outline-container-headline-16 class=outline-2><h2 id=headline-16>Different ways of performing matrix multiplication</h2><div id=outline-text-headline-16 class=outline-text-2><p><sup class=footnote-reference><a id=footnote-reference-1 href=#footnote-1>1</a></sup></p><div id=outline-container-headline-17 class=outline-3><h3 id=headline-17>jki</h3><div id=outline-text-headline-17 class=outline-text-3><div class="src src-c"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> B<span style=color:#f92672>-&gt;</span>col; j<span style=color:#f92672>++</span>) {
 <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; k <span style=color:#f92672>&lt;</span> B<span style=color:#f92672>-&gt;</span>row; k<span style=color:#f92672>++</span>) {
<span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> B<span style=color:#f92672>-&gt;</span>matrix[k][j];
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> A<span style=color:#f92672>-&gt;</span>row; i<span style=color:#f92672>++</span>) {
  C<span style=color:#f92672>-&gt;</span>matrix[i][j] <span style=color:#f92672>+=</span> A<span style=color:#f92672>-&gt;</span>matrix[i][k] <span style=color:#f92672>*</span> r;
}
 }
}</code></pre></div></div><p>This program has the worst performance since it has the worst spatial locality. Suppose the cache can only hold a row of the matrix. Each inner iteration of the innermost loop would lead to a cache miss since; each iteration of the second-most-inner loop too would lead to a cache miss. A cache miss requires CPU to fetch data from memory via bus, which is time consuming comparing to using cache data.</p></div></div><div id=outline-container-headline-18 class=outline-3><h3 id=headline-18>kij</h3><div id=outline-text-headline-18 class=outline-text-3><div class="src src-c"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; k <span style=color:#f92672>&lt;</span> A<span style=color:#f92672>-&gt;</span>col; k<span style=color:#f92672>++</span>) {
 <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> C<span style=color:#f92672>-&gt;</span>row; i<span style=color:#f92672>++</span>) {
<span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> A<span style=color:#f92672>-&gt;</span>matrix[i][k];
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> B<span style=color:#f92672>-&gt;</span>col; j<span style=color:#f92672>++</span>) {
  C<span style=color:#f92672>-&gt;</span>matrix[i][j] <span style=color:#f92672>+=</span> r <span style=color:#f92672>*</span> B<span style=color:#f92672>-&gt;</span>matrix[k][j];
}
 }
}</code></pre></div></div><p>This way of performing matrix multiplication has the best performance since the stride size is smaller and the program takes the advantages of both spatial and temporal locality.</p></div></div><div id=outline-container-headline-19 class=outline-3><h3 id=headline-19>ijk</h3><div id=outline-text-headline-19 class=outline-text-3><div class="src src-c"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> C<span style=color:#f92672>-&gt;</span>row; i<span style=color:#f92672>++</span>) {
 <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> C<span style=color:#f92672>-&gt;</span>col; j<span style=color:#f92672>++</span>) {
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; k <span style=color:#f92672>&lt;</span> A<span style=color:#f92672>-&gt;</span>col; k<span style=color:#f92672>++</span>) {
  C<span style=color:#f92672>-&gt;</span>matrix[i][j] <span style=color:#f92672>+=</span> A<span style=color:#f92672>-&gt;</span>matrix[i][k] <span style=color:#f92672>*</span> B<span style=color:#f92672>-&gt;</span>matrix[k][j];
}
 }
}</code></pre></div></div><p>This program has the moderate performance.</p></div></div><div id=outline-container-headline-20 class=outline-3><h3 id=headline-20>Comparison</h3><div id=outline-text-headline-20 class=outline-text-3><p>Here is a plot comparing the average task completion time of 50 runs of each ways of performing matrix multiplication. It can be seen that generally, <code class=verbatim>kij</code> has the best performance. It advantage is especially notable when the dimension of matrix is increasing, as more L1 cache is used.
<img src=./different_ways.png alt=./different_ways.png title=./different_ways.png></p></div></div></div></div><div id=outline-container-headline-21 class=outline-2><h2 id=headline-21>Different optimization flags on different sizes of matrix</h2><div id=outline-text-headline-21 class=outline-text-2><p><img src=./different_optimization.png alt=./different_optimization.png title=./different_optimization.png>
The plot indicates that <code class=verbatim>-03</code> has the best performance over all the other optimization rules. As the dimension of the matrix involved in the multiplication process increases, the advantage of <code class=verbatim>-O3</code> is more noticeable.
The reason that <code class=verbatim>-O3</code> has the best performance is that <code class=verbatim>-O3</code> attempts to vectorize loops, which are used abundantly in the operation of matrix multiplication. It uses more advanced instruction set that has better arithmetic performance.
It can be seen from the following image that <code class=verbatim>-O2</code> flag together with <code class=verbatim>ftree-vectorize</code> achieve the similar performance of <code class=verbatim>-O3</code>. This phenomenon indicates that vectorization has a great impact on program's performance.
<img src=./vec-o2.png alt=./vec-o2.png title=./vec-o2.png>
Moreover, according to <code class=verbatim>GCC</code>, line <code class=verbatim>112</code> is optimized.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>➜  code gcc-10 matrix_op.c main.c -o matrix_vec -ftree-vectorize -O2 -mavx -fopt-info-vec-optimized
matrix_op.c:112:3: optimized: loop vectorized using 16 byte vectors
matrix_op.c:112:3: optimized:  loop versioned for vectorization because of possible aliasing</code></pre></div></div><p>This line is corresponding to the following <code class=verbatim>C</code> code</p><div class="src src-c"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> B<span style=color:#f92672>-&gt;</span>col; j<span style=color:#f92672>++</span>)</code></pre></div></div><p>Which is an essential part to the matrix multiplication.</p></div></div><div id=outline-container-headline-22 class=outline-2><h2 id=headline-22>-ftree-vectorize</h2><div id=outline-text-headline-22 class=outline-text-2><p>As mentioned above, the most significant optimization in <code class=verbatim>-O3</code> for the program is <code class=verbatim>-ftree-vectorize</code>.
Roughly speaking, when <code class=verbatim>-ftree-vectorize</code> is activated, <code class=verbatim>GCC</code> will try to convert normal loop into loop that utilizes <code class=verbatim>SIMD</code> built-in functions. The <code class=verbatim>tree-vectorizer</code> is going to analyze the loops and then transform the vectorizable loops into the designated form. Each loop and each statement in will be attached by <code class=verbatim>loop_vec_info</code> and <code class=verbatim>stmt_vec_info</code>.
When transforming loop, the program is going to scan every statements inside the loop and create a corresponding vector for everything needed to be vectorized.</p></div></div><div class=footnotes><hr class=footnotes-separatator><div class=footnote-definitions><div class=footnote-definition><sup id=footnote-1><a href=#footnote-reference-1>1</a></sup><div class=footnote-body><p><a href=https://blog.csdn.net/haolexiao/article/details/65936158>https://blog.csdn.net/haolexiao/article/details/65936158</a></p></div></div></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.mrr1vfe.io/tags/c/>C</a></li><li><a href=https://www.mrr1vfe.io/tags/cache/>Cache</a></li><li><a href=https://www.mrr1vfe.io/tags/optimization/>Optimization</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Compiling C code using GCC on twitter" href="https://twitter.com/intent/tweet/?text=Compiling%20C%20code%20using%20GCC&url=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fmatrix%2f&hashtags=C%2cCache%2cOptimization"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Compiling C code using GCC on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fmatrix%2f&title=Compiling%20C%20code%20using%20GCC&summary=Compiling%20C%20code%20using%20GCC&source=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fmatrix%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Compiling C code using GCC on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fmatrix%2f&title=Compiling%20C%20code%20using%20GCC"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Compiling C code using GCC on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fmatrix%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Compiling C code using GCC on whatsapp" href="https://api.whatsapp.com/send?text=Compiling%20C%20code%20using%20GCC%20-%20https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fmatrix%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Compiling C code using GCC on telegram" href="https://telegram.me/share/url?text=Compiling%20C%20code%20using%20GCC&url=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fmatrix%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://www.mrr1vfe.io/>mrr1vfe</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>