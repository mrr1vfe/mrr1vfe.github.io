<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Theory and Design of Programming Languages | mrr1vfe</title><meta name=keywords content="Haskell,Rust,Lambda-Calculus"><meta name=description content="Lecture 1 1  Functional programming  History    Based on $\lambda$ calculus
  Lisp
  ML
  Haskell
    Building block    function   take inputs as arguments and produce outputs.
  Functions are first class, like any other value. They can be passed to, returned by functions. Functions can also be combined into new function."><meta name=author content="Reid Chen"><link rel=canonical href=https://www.mrr1vfe.io/posts/cs538/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.mrr1vfe.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.mrr1vfe.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.mrr1vfe.io/favicon-32x32.png><link rel=apple-touch-icon href=https://www.mrr1vfe.io/apple-touch-icon.png><link rel=mask-icon href=https://www.mrr1vfe.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.0"><meta property="og:title" content="Theory and Design of Programming Languages"><meta property="og:description" content="Lecture 1 1  Functional programming  History    Based on $\lambda$ calculus
  Lisp
  ML
  Haskell
    Building block    function   take inputs as arguments and produce outputs.
  Functions are first class, like any other value. They can be passed to, returned by functions. Functions can also be combined into new function."><meta property="og:type" content="article"><meta property="og:url" content="https://www.mrr1vfe.io/posts/cs538/"><meta property="og:image" content="https://www.mrr1vfe.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-30T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-30T00:00:00+00:00"><meta property="og:see_also" content="https://www.mrr1vfe.io/posts/cs532/"><meta property="og:see_also" content="https://www.mrr1vfe.io/posts/cs540/"><meta property="og:see_also" content="https://www.mrr1vfe.io/posts/cs537/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.mrr1vfe.io/papermod-cover.png"><meta name=twitter:title content="Theory and Design of Programming Languages"><meta name=twitter:description content="Lecture 1 1  Functional programming  History    Based on $\lambda$ calculus
  Lisp
  ML
  Haskell
    Building block    function   take inputs as arguments and produce outputs.
  Functions are first class, like any other value. They can be passed to, returned by functions. Functions can also be combined into new function."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.mrr1vfe.io/posts/"},{"@type":"ListItem","position":2,"name":"Theory and Design of Programming Languages","item":"https://www.mrr1vfe.io/posts/cs538/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Theory and Design of Programming Languages","name":"Theory and Design of Programming Languages","description":"Lecture 1 1  Functional programming  History    Based on $\\lambda$ calculus\n  Lisp\n  ML\n  Haskell\n    Building block    function   take inputs as arguments and produce outputs.\n  Functions are first class, like any other value. They can be passed to, returned by functions. Functions can also be combined into new function.","keywords":["Haskell","Rust","Lambda-Calculus"],"articleBody":" Lecture 1 1  Functional programming  History    Based on $\\lambda$ calculus\n  Lisp\n  ML\n  Haskell\n    Building block    function   take inputs as arguments and produce outputs.\n  Functions are first class, like any other value. They can be passed to, returned by functions. Functions can also be combined into new function.\n  Control side-effects  Think about program is isolation\n  pure function   Described only by input and output. Always returns same result on fixed input.\n  Hidden state   avoid counters, local variables, etc.\n  Manage side-effects         A taste of Haskell  Declaring function  -- double is function's name, :: indicates the type of this function. Int - Int means it takes a Int as an input and outputs an Int double :: Int - Int -- this line is optional, optional type signature / type annotation double n = n + n -- this is the function definition    Calling function  myBool = myFun 42 -- myFun is function name, 42 is the argument myBool = constFun () -- () called unit, not taking value    Multiple arguments  doubleTwos :: Int - Int - Int doubleTwos x y = double x + double y    Case analysis  doubleIfBig :: Int - Int doubleIfBig n = if (n  100) then n + n else n  or\ndoubleIfBig' n | n  100 = n + n | otherwise = n    Case expression  listPrint :: [Int] - String listPrint l = case l of [] - \"Empty\" (x:xs) - show x ++ \" and \" ++ show xs  or\nlistPrint :: [Int] - String listPrint [] = \"Empty list\" listPrint (x:xs) = \"...\" -- x is the first element, xs is the rest of the list    Declare variables  tripleSecret :: Int tripleSecret = let secret = mySecretNum other = myOtherNum in 3 * secret + other  or\ntripleSecret = 3 * secret + other where secret = mySecret other = myOther    Tuples  Tuple can mix and match different types. An empty tuple is unit type.\nmyTuple :: (Int, Int) myTuple = (7, 42) myTriple :: (Int, Int, Int) myTriple = (7, 42, 108)    List  List takes same type, unlike tuple.\nmyList :: [Int]        Functional Programming 2  Compilation  Compile code\nghc --make [filename.hs]    Keywords    Do   The do keyword introduces a block of actions that can cause effects in the real world, such as reading or writing a file.\n   Assignment operator inside the do block.\n    lines  The function, lines, are able to convert a string to a list of strings where each item in the list is a line in the given string. The \\n of a line will be discarded. However, when reading a file coming from Windows system, which prefers to put \\r\\n at the end of each line, using lines to split a string on an unix-based system would be a mess. The \\r will be remained in each item of the generated list. The following code are able to handle the \\r and \\r\\n cases.\nsplitLines :: String - [String] splitLines [] = [] -- do nothing when facing an empty string splitLines cs = let (pre, suf) = break isLineTerminator cs -- pre contains substring before newline characters, suf contains everything else in pre : case suf of -- : operator is used to concatenate pre and modified suf ('\\r':'\\n':rest) - splitLines rest -- rest is the remainder of the suf ('\\r':rest) - splitLines rest ('\\n':rest) - splitLines rest _ - [] isLineTerminator c = c == '\\r' || c == '\\n'  When writing the code, organize the important part first. Give functions easy-to-understand name. Define less important function at the end is okay. The break provided by Prelude can break a list into two parts. break takes two arguments. The first one should be a function returns a boolean value, and the second one is a list. The function will examine each element of the list and decide if split at that element of not. If split, then return True, otherwise False. break is going to return a tuple of two lists. The first lists does not include the item which causes the function argument returning True.\nbreak (\\x-x) [False, False, True, True] -- output: ([False,False],[True,True])    Infix    prefix   Writing the name of the function before its arguments.\n  infix   When a function has more than 1 arguments, it can be placed in between its first and second arguments.\n  a `times` b = a * b  infix notation does not change function's behavior. It improves readability.\n  Data.List  prelude only exports a partial of functions in Data.List. In order to use all functions of Data.List in ghci, enter the following command\n:module +Data.List    length   return the number of elements in a list\n  null   determine whether a list is empty\n  head   access the first element of a list\n  tail   return a list of all but head\n  last   access the last element of a list\n  init   return a list of all but tail\n  Why not using length to check emptiness? List in Haskell does not contain its size. Therefore, length has to go through a whole list to find its size. In other words, length runs in liner time. A better alternative, null, not only runs in constant time but also clearly indicates the function of the code containing it.\n  partial functions   return values defined for a subset of valid inputs, like head\n  total functions   return valid results over their entire input domain\n  ++   append an list to another list\n  concat   concatenate a list of lists into a list; remove one level of nesting\n  reverse   reverse list order\n  and   and each element of a list of bool\n  or   or each element of a list of bool\n  all   takes a predicate, return True if the predicate succeeds on every element of a list\n  any   takes a predicate, return True if the predicate succeeds on at least one element of a list\n  Sublists    take   return a sublist of first $k$ elements\n  drop   return a sublist of without the first $k$ elements\n  split   split a list at index $k$; return a 2-tuple of list, item at index $k$ belongs to the second element of the tuple\n  takeWhile   take element from the beginning of the list as long as a predicate returns True\n  dropWhile   drop element from the beginning of the list as long as a predicate returns True\n  break   consume elements when predicate fails\n  span   consume elements when predicate is True\n    Searching List    elem   return true if an element is in a list\n  notElem   return true if an element is not in a list\n  filter   return all elements on which predicate succeeds\n  isPrefixOf   return true if a sublist appears in the front of a list\n  isInfixOf   return true if a sublist appears in a list\n  isSuffixOf   return true if a sublist appears in the end of a list\n    Multiple List    zip   combine two lists into a lists of pair, then length of the new list is the minimum length of the 2 given lists\n  zipWith   When zipping, apply a function\n    String handling    lines   partition a string into a list of substring based on \\n\n  unlines   concatenate a list of strings into a string. \\n is used to connect each element\n  words   partition a string into a list of substring based on space\n  unwords   concatenate a list of strings into a string. space is used to connect each element\n      Loops  There is not traditional loop in Haskell. Use recursion instead.\n  tail recursive function   function call itself at the end\n  Normally, a large amount of times of recursion will lead to stack overflow. However, functional programming languages implement TCO, or tail call optimization, to detect and transform tail recursion to constant space However, if need to apply function to each element of a list, map is a good function to use\n  high order function   function that takes another function as an argument\n  Fold    foldl   Fold from left of the list. Take a step function, an initial value for its accumulator, and a list.\n  step function   Take accumulator, an element from list, and return new accumulator; define how to update the accumulator in foldl\n  foldr   Fold from right of the list.\n  primitive recursive   class of functions that can be expressed using foldr\n  foldl could cause stack overflow due to the laziness of Haskell. Use foldl' from Data.List\n    Lambda Function    \\ [arguments] - [function body / definition]\n  use a parentheses to let Haskell know where is the end of the function body\n  can only have one single clause in definition\n    Partial Function and Currying  In Haskell, all functions only take one argument.   partial function   the function formed by passing fewer arguments to an existing function\n  currying   application of partial function\n  section   enclose an operator in parentheses, supply its left or right argument inside the parentheses to get a partially applied function\n    As-pattern  xs@(_:xs') is called an as-pattern, and it means “bind the variable xs to the value that matches the right side of the @ symbol. As-pattern allows sharing data. Thus a little bit better runtime than copying data.\n    Type Systems  Each program $e$ has a type $t$. Types describe what kind of program $e$ is, i.e. Boolean, Integer, etc. Some programs do not have a type but all programs have at most one type.\\\\\nBase types  The base types used in class are only \"bool\" for boolean and \"int\" for integer.\nbase-ty = \"bool\" | \"int\"    Function types  Type for lambda calculus. Denoted as ty - ty. The first ty is the input type and the second ty is the output type. Note that both input and output can be functions.\nty = base-ty | ty - ty    Full simple types examples  true has type bool 42 has type int plusOne = \\lambda x. x + 1 has type =int - int\n  Typing context  Type depends on types of free variables in open terms. This kind of types are tracked in a typing context $G$\n  binding   $(x : t)$ means variable $x$ has type $t$\n  A typing context is a list of bindings. For example, A two-binding context $G$ is $G = x : bool, y : int$. Empty context is denoted as $G = \\cdot$.\n  Together  $G \\vdash e : t$ means program $e$ has type $t$ in context $G$.\n  Unicity of Typing   For every typing context $G$ and expression $e$, there exists at most one type $t$ such that $G \\vdash e : t$.\n  Inversion for Typing   Suppose that $G \\vdash e :t$. If $e = \\mathrm{add}(e_1, e_2)$, then $t = int, G \\vdash e_1 : int$, and $G \\vdash e_2 : int$.\n      Typeclasses 3  Define a Typeclass  class Typeclass name instance types where function type prototype here  Note that the keyword class here is different from the class in object-oriented languages.\n  instance type   type that implements the functions defined in the typeclass\n  For example:\nclass BasicEq a where -- the a is chosen arbitrary isEqual :: a - a - Bool -- defines one funciton  Interpret the type of a typeclass  The type of isEqual is\nisEqual :: BasicEq a = a - a - Bool  = is a type class constraint. The type of isEqual means if a is an instance of BasicEq, then isEqual takes two a as parameters and return a Bool.\n    Define an instance  instance Typeclass name instance type where functions here  For example\ninstance BasicEq Bool where isEqual True True = True isEqual False False = True isEqual _ _ = True  Now, isEqual works for Bool, but not for any other types since there is no instance created for other types. The compiler does not know how to compare types other than Bool\n    Review I  Haskell  Function    Multiple arguments, Anonymous Functions (\\x - x + 1)\n    Recursions  f :: [a] - Int - [a] f list times = concat $ map dup list where dup 0 x = [] dup times x = x : dup (times - 1) x    Higher older function  .  (a - b) - (b - c) - (a - c) function composition\n  $  function application\n  map\n  foldr\n  zip\n      Curry  ((a, b) - c) - a - b - c\n  Types  (newtype, data (most powerful), type (least powerful))\n  type has to use with existed type\ntype Dollar = Int    newtype only has one field\nnewtype AppendList a = AList ([a] - [a])    data could be anything. Like a tree, node, etc.\ndata Tree = Leaf a | Node Left Mid Right | Child [a] | Empty      Typeclasses / subclasses  Functors  Functor m pure :: a - m a pure a = Just a fmap (a - b) - m a - m b --  is fmap fmap f m = case m of Nothing - Nothing Just val - Just $ f val    Applicative\n    Monads\n  IO Monads\n          Theory    Syntax\n  digit = 0 | 1 | 2 | 3 … exp = num + exp | exp\n    Lambdas Calculus (Not-typed)\n  Semantics (small-step)\n  Type theory (add safety = progress(can step) + preservation(step to same type))\n  Bigger Types (P × Q, P + Q)\n      Rust Language  [[./TRPL.html][Notes on The Rust Programming Language]\n  References and Borrowing    References is an indirect name for some data. Similar to a pointer to some data.\n  Reference does not own the data.\n  Can have only one owner, but many references.\n    Reference going out of scope does not drop data.\n  Can \"borrow\" reference to function\n    Function can take (mutable) reference and modify caller's data directly\n  Useful for mutable datastructures.\n    Reference themselves are on stack.\n  By default, references are immutable.\n  Can't change underlying data through references.\n  Reference type: \u0026T\n    Can declare mutable references\n  Target must be mutable as well\n  Reference type: \u0026mut T\n  let must my_str = String::from(\"foo\"); // mutable var let ref_to_str = \u0026mut my_str; // mutable ref to my_str     Dereferencing    Use * notation to get thing reference is pointing at\n  Often not needed due to \"auto-deref\" (magic)\nlet vr: \u0026Veci32 = ...; println!(\"First element: {}\", (*vr)[0]); // Explicit deref println!(\"First element: {}\", vr[0]); // Implicit deref println!(\"First element: {}\", vr.first); // Implicit deref       Somewhat confusingly  Reference itself can be mutable\n// Can't change ref or thing it's pointing at let immut_ref_to_immut = \u0026my_string; // Can't change ref, can change thing it's pointing at let immut_ref_to_mut = \u0026mut my_string; // Can change ref, can't change thing it's pointing at let mut mut_ref_to_immut = \u0026my_string; mut_ref_to_immut = \u0026my_other_string; // Can change ref and thing it's poing at let mut mut_ref_to_mut = \u0026mut my_string; mut_ref_to_mut = \u0026mut my_other_string; *mut_ref_to_mut = String::from(\"???\");    What's going one    Mutability is not a property of the data!\n  Not: these bits are mutable or immutable\n    Mutability is property of variable or reference\n  YES: I can mutate data through this variable\n  YES: I cannot mutate data through that reference\n      Multiple References    Rust works hard to ensure one owner for each data\n  Multiple references to same data is problematic\n  Also known as aliasing\n    References need to follow certain rules for safty\n  In any scope, there can be either:\n  Any number of immutable references referring to the same variable\n  At most one mutable reference referring to the same variable\n      Multiple Immutable    Can have any number of immutable references to variable\n  Safe: none of the references can change the underlying\nlet my_str = String::from(\"foo\"); let ref_one = \u0026my_str; let ref_two = \u0026my_str; println!(\"Both refs: {} {}\", ref_one, ref_two); // OK       At Most One Mutable    Can only change underlying through single reference\n  Also important in concurrent setting\n  Also enables more optimizations\n  let mut mut_str = String::from(\"foo\"); let ref_one = \u0026mut mut_str; // OK let ref_two = \u0026mut mut_str; // Not OK       Use Scopes to Manage References  Rules only apply to references currently in scope.\nlet mut mut_str = String::from(\"foo\"); let mut_ref = \u0026mut mut_str; mut_ref.push(\"bar\"); // OK mut_str.push(\"baz\"); // Not OK  // Use scopes! let mut mut_str = String::from(\"foo\"); { let mut_ref = \u0026mut mut_str; mut_ref.push(\"bar\"); // OK } mut_str.push(\"baz\"); // OK     Alternative Reading    Immutable reference shared reference\n  Shared access to some data\n  Sharing: can't change the data\n    Mutable reference: unique reference\n  Exclusive access to some data\n  Can modify it: no one else has access\n    Can't mix shared and unique!\n    Isn't a Reference Just a Pointer?    In machine code: a reference is just a pointer\n  In Rust: a reference also gives permissions to do things\n  With an immutable reference, code can\n  Dereference/read location\n  Point to/read anything reachable from reference.\n    With an mutable reference, code can\n  Dereference/read/write location\n  Point to/read/write anything reachable from reference.\n      Passing Arguments  \"Moving\" Arguments    Operationally: arguments passed \"by value\"\n  Ownership of argument passes into the function\n  Caller can't use arguments after calling!\n  Arguments moved into function\n    Function can return argument to return ownership\n    \"Borrowing\" Arguments    Operationally: arguments passed \"by reference\"\n  Ownership of argument doesn't change\n  Original owner (caller, caller-of-caller, …) owns argument.\n    Function borrows arguments from the owner\n  Will give it back to owner when done with it\n        Variables Are Key    Anywhere there are variables:\n  Think about ownership rules\n  Think about borrowing rules\n      Matching Can Move Data    Often: matching on Enums with data inside\n  The inner data is moved into the match arm\n  Variable from match arm has ownership\n    Typical ownership rules apply\n  Data is dropped at the end of the arm\n      Matching on a reference    Rust will infer how to borrow inner values\n  Matching on \u0026T type: arms borrow immutable\n  Marching on \u0026must T type: arms borrow mutable\n    Also called \"default binding modes\"\n  Usually: Just work\n  Sometimes; inferences goes wrong (doesn't work)\n        1 The whole note is based on and is coming from the course materials of COMP SCI 538 by Professor Justin Hsu.\n  2 Notes from Real World Haskell by Bryan O'Sullivan, Don Stewart, and John Goerze\n  3 Notes from Real World Haskell by Bryan O'Sullivan, Don Stewart, and John Goerze\n  Typeclasses   Typeclasses define a set of functions that can have different implementations depending on the type of data they are given.\n      ","wordCount":"2949","inLanguage":"en","datePublished":"2020-04-30T00:00:00Z","dateModified":"2020-04-30T00:00:00Z","author":{"@type":"Person","name":"Reid Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.mrr1vfe.io/posts/cs538/"},"publisher":{"@type":"Organization","name":"mrr1vfe","logo":{"@type":"ImageObject","url":"https://www.mrr1vfe.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://www.mrr1vfe.io/ accesskey=h title="mrr1vfe (Alt + H)">mrr1vfe</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.mrr1vfe.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://www.mrr1vfe.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://www.mrr1vfe.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.mrr1vfe.io/series title=Series><span>Series</span></a></li><li><a href=https://www.mrr1vfe.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://archive.casouri.cat/ title=BHL0388><span>BHL0388</span></a></li><li><a href=https://archive.casouri.cat/goldfish/index.html title=金鱼><span>金鱼</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Theory and Design of Programming Languages</h1><div class=post-meta>April 30, 2020&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Reid Chen</div></header><div class=post-content><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>Lecture 1 <sup class=footnote-reference><a id=footnote-reference-1 href=#footnote-1>1</a></sup></h2><div id=outline-text-headline-1 class=outline-text-2><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>Functional programming</h3><div id=outline-text-headline-2 class=outline-text-3><div id=outline-container-headline-3 class=outline-4><h4 id=headline-3>History</h4><div id=outline-text-headline-3 class=outline-text-4><ul><li><p>Based on $\lambda$ calculus</p></li><li><p>Lisp</p></li><li><p>ML</p></li><li><p>Haskell</p></li></ul></div></div><div id=outline-container-headline-4 class=outline-4><h4 id=headline-4>Building block</h4><div id=outline-text-headline-4 class=outline-text-4><dl><dt>function</dt><dd><p>take <strong>inputs</strong> as arguments and produce <strong>outputs</strong>.</p></dd></dl><p>Functions are first class, like any other value. They can be passed to, returned by functions. Functions can also be combined into new function.</p></div></div><div id=outline-container-headline-5 class=outline-4><h4 id=headline-5>Control side-effects</h4><div id=outline-text-headline-5 class=outline-text-4><p>Think about program is isolation</p><dl><dt>pure function</dt><dd><p>Described only by input and output. Always returns same result on fixed input.</p></dd><dt>Hidden state</dt><dd><p>avoid counters, local variables, etc.</p></dd><dt>Manage side-effects</dt><dd></dd></dl></div></div></div></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>A taste of Haskell</h3><div id=outline-text-headline-6 class=outline-text-3><div id=outline-container-headline-7 class=outline-4><h4 id=headline-7>Declaring function</h4><div id=outline-text-headline-7 class=outline-text-4><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- double is function&#39;s name, :: indicates the type of this function. Int -&gt; Int means it takes a Int as an input and outputs an Int</span>
<span style=color:#a6e22e>double</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span> <span style=color:#75715e>-- this line is optional, optional type signature / type annotation</span>
<span style=color:#a6e22e>double</span> n <span style=color:#f92672>=</span> n <span style=color:#f92672>+</span> n <span style=color:#75715e>-- this is the function definition</span></code></pre></div></div></div></div><div id=outline-container-headline-8 class=outline-4><h4 id=headline-8>Calling function</h4><div id=outline-text-headline-8 class=outline-text-4><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>myBool</span> <span style=color:#f92672>=</span> myFun <span style=color:#ae81ff>42</span> <span style=color:#75715e>-- myFun is function name, 42 is the argument</span>
<span style=color:#a6e22e>myBool</span> <span style=color:#f92672>=</span> constFun () <span style=color:#75715e>-- () called unit, not taking value</span></code></pre></div></div></div></div><div id=outline-container-headline-9 class=outline-4><h4 id=headline-9>Multiple arguments</h4><div id=outline-text-headline-9 class=outline-text-4><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>doubleTwos</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span>
<span style=color:#a6e22e>doubleTwos</span> x y <span style=color:#f92672>=</span> double x <span style=color:#f92672>+</span> double y</code></pre></div></div></div></div><div id=outline-container-headline-10 class=outline-4><h4 id=headline-10>Case analysis</h4><div id=outline-text-headline-10 class=outline-text-4><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>doubleIfBig</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span>
<span style=color:#a6e22e>doubleIfBig</span> n <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span>) <span style=color:#66d9ef>then</span> n <span style=color:#f92672>+</span> n <span style=color:#66d9ef>else</span> n</code></pre></div></div><p>or</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>doubleIfBig&#39;</span> n
    <span style=color:#f92672>|</span> n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span> <span style=color:#f92672>=</span> n <span style=color:#f92672>+</span> n
<span style=color:#f92672>|</span> otherwise <span style=color:#f92672>=</span> n</code></pre></div></div></div></div><div id=outline-container-headline-11 class=outline-4><h4 id=headline-11>Case expression</h4><div id=outline-text-headline-11 class=outline-text-4><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>listPrint</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>Int</span>] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>String</span>
<span style=color:#a6e22e>listPrint</span> l <span style=color:#f92672>=</span> <span style=color:#66d9ef>case</span> l <span style=color:#66d9ef>of</span>
              <span style=color:#66d9ef>[]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#34;Empty&#34;</span>
              (x<span style=color:#66d9ef>:</span>xs) <span style=color:#f92672>-&gt;</span> show x <span style=color:#f92672>++</span> <span style=color:#e6db74>&#34; and &#34;</span> <span style=color:#f92672>++</span> show xs</code></pre></div></div><p>or</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>listPrint</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>Int</span>] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>String</span>
<span style=color:#a6e22e>listPrint</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Empty list&#34;</span>
<span style=color:#a6e22e>listPrint</span> (x<span style=color:#66d9ef>:</span>xs) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;...&#34;</span> <span style=color:#75715e>-- x is the first element, xs is the rest of the list</span></code></pre></div></div></div></div><div id=outline-container-headline-12 class=outline-4><h4 id=headline-12>Declare variables</h4><div id=outline-text-headline-12 class=outline-text-4><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>tripleSecret</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span>
<span style=color:#a6e22e>tripleSecret</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>let</span> secret <span style=color:#f92672>=</span> mySecretNum
                    other <span style=color:#f92672>=</span> myOtherNum
               <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> secret <span style=color:#f92672>+</span> other</code></pre></div></div><p>or</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>tripleSecret</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> secret <span style=color:#f92672>+</span> other
               <span style=color:#66d9ef>where</span> secret <span style=color:#f92672>=</span> mySecret
                      other <span style=color:#f92672>=</span> myOther</code></pre></div></div></div></div><div id=outline-container-headline-13 class=outline-4><h4 id=headline-13>Tuples</h4><div id=outline-text-headline-13 class=outline-text-4><p>Tuple can mix and match different types. An empty tuple is unit type.</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>myTuple</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Int</span>, <span style=color:#66d9ef>Int</span>)
<span style=color:#a6e22e>myTuple</span> <span style=color:#f92672>=</span> (<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>42</span>)
<span style=color:#a6e22e>myTriple</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Int</span>, <span style=color:#66d9ef>Int</span>, <span style=color:#66d9ef>Int</span>)
<span style=color:#a6e22e>myTriple</span> <span style=color:#f92672>=</span> (<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>42</span>, <span style=color:#ae81ff>108</span>)</code></pre></div></div></div></div><div id=outline-container-headline-14 class=outline-4><h4 id=headline-14>List</h4><div id=outline-text-headline-14 class=outline-text-4><p>List takes same type, unlike tuple.</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>myList</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>Int</span>]</code></pre></div></div></div></div></div></div></div></div><div id=outline-container-headline-15 class=outline-2><h2 id=headline-15>Functional Programming <sup class=footnote-reference><a id=footnote-reference-2 href=#footnote-2>2</a></sup></h2><div id=outline-text-headline-15 class=outline-text-2><div id=outline-container-headline-16 class=outline-3><h3 id=headline-16>Compilation</h3><div id=outline-text-headline-16 class=outline-text-3><p>Compile code</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>ghc --make [filename.hs]</code></pre></div></div></div></div><div id=outline-container-headline-17 class=outline-3><h3 id=headline-17>Keywords</h3><div id=outline-text-headline-17 class=outline-text-3><dl><dt>Do</dt><dd><p>The <code class=verbatim>do</code> keyword introduces a block of actions that can cause effects in the real world, such as reading or writing a file.</p></dd><dt>&lt;-</dt><dd><p>Assignment operator inside the do block.</p></dd></dl></div></div><div id=outline-container-headline-18 class=outline-3><h3 id=headline-18>lines</h3><div id=outline-text-headline-18 class=outline-text-3><p>The function, <code class=verbatim>lines</code>, are able to convert a string to a list of strings where each item in the list is a line in the given string. The <code class=verbatim>\n</code> of a line will be discarded. However, when reading a file coming from Windows system, which prefers to put <code class=verbatim>\r\n</code> at the end of each line, using <code class=verbatim>lines</code> to split a string on an unix-based system would be a mess. The <code class=verbatim>\r</code> will be remained in each item of the generated list.<br>The following code are able to handle the <code class=verbatim>\r</code> and <code class=verbatim>\r\n</code> cases.</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>splitLines</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>-&gt;</span> [<span style=color:#66d9ef>String</span>]
<span style=color:#a6e22e>splitLines</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>[]</span> <span style=color:#75715e>-- do nothing when facing an empty string</span>
<span style=color:#a6e22e>splitLines</span> cs <span style=color:#f92672>=</span>
    <span style=color:#66d9ef>let</span> (pre, suf) <span style=color:#f92672>=</span> break isLineTerminator cs <span style=color:#75715e>-- pre contains substring before newline characters, suf contains everything else</span>
    <span style=color:#66d9ef>in</span> pre <span style=color:#66d9ef>:</span> <span style=color:#66d9ef>case</span> suf <span style=color:#66d9ef>of</span> <span style=color:#75715e>-- : operator is used to concatenate pre and modified suf</span>
(<span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\r</span><span style=color:#e6db74>&#39;</span><span style=color:#66d9ef>:</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span><span style=color:#66d9ef>:</span>rest) <span style=color:#f92672>-&gt;</span> splitLines rest <span style=color:#75715e>-- rest is the remainder of the suf</span>
(<span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\r</span><span style=color:#e6db74>&#39;</span><span style=color:#66d9ef>:</span>rest) <span style=color:#f92672>-&gt;</span> splitLines rest
(<span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span><span style=color:#66d9ef>:</span>rest) <span style=color:#f92672>-&gt;</span> splitLines rest
<span style=color:#66d9ef>_</span>           <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>[]</span>

  isLineTerminator c <span style=color:#f92672>=</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\r</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>||</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span></code></pre></div></div><p>When writing the code, organize the important part first. Give functions easy-to-understand name. Define less important function at the end is okay.<br>The <code class=verbatim>break</code> provided by <code class=verbatim>Prelude</code> can break a list into two parts. <code class=verbatim>break</code> takes two arguments. The first one should be a function returns a boolean value, and the second one is a list. The function will examine each element of the list and decide if split at that element of not. If split, then return <code class=verbatim>True</code>, otherwise <code class=verbatim>False</code>. <code class=verbatim>break</code> is going to return a tuple of two lists. The first lists does not include the item which causes the function argument returning <code class=verbatim>True</code>.</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>break</span> (<span style=color:#a6e22e>\</span>x<span style=color:#f92672>-&gt;</span>x) [<span style=color:#66d9ef>False</span>, <span style=color:#66d9ef>False</span>, <span style=color:#66d9ef>True</span>, <span style=color:#66d9ef>True</span>]
<span style=color:#75715e>-- output: ([False,False],[True,True])</span></code></pre></div></div></div></div><div id=outline-container-headline-19 class=outline-3><h3 id=headline-19>Infix</h3><div id=outline-text-headline-19 class=outline-text-3><dl><dt>prefix</dt><dd><p>Writing the name of the function before its arguments.</p></dd><dt>infix</dt><dd><p>When a function has more than 1 arguments, it can be placed in between its first and second arguments.</p></dd></dl><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>a</span> `times` b <span style=color:#f92672>=</span> a <span style=color:#f92672>*</span> b</code></pre></div></div><p><code class=verbatim>infix</code> notation does not change function's behavior. It improves readability.</p></div></div><div id=outline-container-headline-20 class=outline-3><h3 id=headline-20>Data.List</h3><div id=outline-text-headline-20 class=outline-text-3><p><code class=verbatim>prelude</code> only exports a partial of functions in Data.List. In order to use all functions of <code class=verbatim>Data.List</code> in <code class=verbatim>ghci</code>, enter the following command</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>:module +Data.List</code></pre></div></div><dl><dt>length</dt><dd><p>return the number of elements in a list</p></dd><dt>null</dt><dd><p>determine whether a list is empty</p></dd><dt>head</dt><dd><p>access the first element of a list</p></dd><dt>tail</dt><dd><p>return a list of all but head</p></dd><dt>last</dt><dd><p>access the last element of a list</p></dd><dt>init</dt><dd><p>return a list of all but tail</p></dd></dl><p>Why not using <code class=verbatim>length</code> to check emptiness? List in Haskell does not contain its size. Therefore, <code class=verbatim>length</code> has to go through a whole list to find its size. In other words, <code class=verbatim>length</code> runs in liner time. A better alternative, <code class=verbatim>null</code>, not only runs in constant time but also clearly indicates the function of the code containing it.</p><dl><dt>partial functions</dt><dd><p>return values defined for a subset of valid inputs, like <code class=verbatim>head</code></p></dd><dt>total functions</dt><dd><p>return valid results over their entire input domain</p></dd><dt>++</dt><dd><p>append an list to another list</p></dd><dt>concat</dt><dd><p>concatenate a list of lists into a list; remove one level of nesting</p></dd><dt>reverse</dt><dd><p>reverse list order</p></dd><dt>and</dt><dd><p>and each element of a list of bool</p></dd><dt>or</dt><dd><p>or each element of a list of bool</p></dd><dt>all</dt><dd><p>takes a predicate, return <code class=verbatim>True</code> if the predicate succeeds on every element of a list</p></dd><dt>any</dt><dd><p>takes a predicate, return <code class=verbatim>True</code> if the predicate succeeds on at least one element of a list</p></dd></dl><div id=outline-container-headline-21 class=outline-4><h4 id=headline-21>Sublists</h4><div id=outline-text-headline-21 class=outline-text-4><dl><dt>take</dt><dd><p>return a sublist of first $k$ elements</p></dd><dt>drop</dt><dd><p>return a sublist of without the first $k$ elements</p></dd><dt>split</dt><dd><p>split a list at index $k$; return a 2-tuple of list, item at index $k$ belongs to the second element of the tuple</p></dd><dt>takeWhile</dt><dd><p>take element from the beginning of the list as long as a predicate returns <code class=verbatim>True</code></p></dd><dt>dropWhile</dt><dd><p>drop element from the beginning of the list as long as a predicate returns <code class=verbatim>True</code></p></dd><dt>break</dt><dd><p>consume elements when predicate fails</p></dd><dt>span</dt><dd><p>consume elements when predicate is <code class=verbatim>True</code></p></dd></dl></div></div><div id=outline-container-headline-22 class=outline-4><h4 id=headline-22>Searching List</h4><div id=outline-text-headline-22 class=outline-text-4><dl><dt>elem</dt><dd><p>return true if an element is in a list</p></dd><dt>notElem</dt><dd><p>return true if an element is not in a list</p></dd><dt>filter</dt><dd><p>return all elements on which predicate succeeds</p></dd><dt>isPrefixOf</dt><dd><p>return true if a sublist appears in the front of a list</p></dd><dt>isInfixOf</dt><dd><p>return true if a sublist appears in a list</p></dd><dt>isSuffixOf</dt><dd><p>return true if a sublist appears in the end of a list</p></dd></dl></div></div><div id=outline-container-headline-23 class=outline-4><h4 id=headline-23>Multiple List</h4><div id=outline-text-headline-23 class=outline-text-4><dl><dt>zip</dt><dd><p>combine two lists into a lists of pair, then length of the new list is the minimum length of the 2 given lists</p></dd><dt>zipWith</dt><dd><p>When zipping, apply a function</p></dd></dl></div></div><div id=outline-container-headline-24 class=outline-4><h4 id=headline-24>String handling</h4><div id=outline-text-headline-24 class=outline-text-4><dl><dt>lines</dt><dd><p>partition a string into a list of substring based on <code class=verbatim>\n</code></p></dd><dt>unlines</dt><dd><p>concatenate a list of strings into a string. <code class=verbatim>\n</code> is used to connect each element</p></dd><dt>words</dt><dd><p>partition a string into a list of substring based on <code class=verbatim>space</code></p></dd><dt>unwords</dt><dd><p>concatenate a list of strings into a string. <code class=verbatim>space</code> is used to connect each element</p></dd></dl></div></div></div></div><div id=outline-container-headline-25 class=outline-3><h3 id=headline-25>Loops</h3><div id=outline-text-headline-25 class=outline-text-3><p>There is not traditional loop in Haskell. Use recursion instead.</p><dl><dt>tail recursive function</dt><dd><p>function call itself at the end</p></dd></dl><p>Normally, a large amount of times of recursion will lead to stack overflow. However, functional programming languages implement TCO, or tail call optimization, to detect and transform tail recursion to constant space
However, if need to apply function to each element of a list, <code class=verbatim>map</code> is a good function to use</p><dl><dt>high order function</dt><dd><p>function that takes another function as an argument</p></dd></dl><div id=outline-container-headline-26 class=outline-4><h4 id=headline-26>Fold</h4><div id=outline-text-headline-26 class=outline-text-4><dl><dt>foldl</dt><dd><p>Fold from left of the list. Take a step function, an initial value for its accumulator, and a list.</p></dd><dt>step function</dt><dd><p>Take accumulator, an element from list, and return new accumulator; define how to update the accumulator in <code class=verbatim>foldl</code></p></dd><dt>foldr</dt><dd><p>Fold from right of the list.</p></dd><dt>primitive recursive</dt><dd><p>class of functions that can be expressed using <code class=verbatim>foldr</code></p></dd></dl><p><code class=verbatim>foldl</code> could cause stack overflow due to the laziness of Haskell. Use <code class=verbatim>foldl'</code> from <code class=verbatim>Data.List</code></p></div></div></div></div><div id=outline-container-headline-27 class=outline-3><h3 id=headline-27>Lambda Function</h3><div id=outline-text-headline-27 class=outline-text-3><ul><li><p>\ [arguments] -> [function body / definition]</p></li><li><p>use a parentheses to let Haskell know where is the end of the function body</p></li><li><p>can only have one single clause in definition</p></li></ul></div></div><div id=outline-container-headline-28 class=outline-3><h3 id=headline-28>Partial Function and Currying</h3><div id=outline-text-headline-28 class=outline-text-3><p>In Haskell, all functions only take one argument.</p><dl><dt>partial function</dt><dd><p>the function formed by passing fewer arguments to an existing function</p></dd><dt>currying</dt><dd><p>application of partial function</p></dd><dt>section</dt><dd><p>enclose an operator in parentheses, supply its left or right argument inside the parentheses to get a partially applied function</p></dd></dl></div></div><div id=outline-container-headline-29 class=outline-3><h3 id=headline-29>As-pattern</h3><div id=outline-text-headline-29 class=outline-text-3><p>xs@(_:xs') is called an as-pattern, and it means “bind the variable xs to the value that matches the right side of the @ symbol. As-pattern allows sharing data. Thus a little bit better runtime than copying data.</p></div></div></div></div><div id=outline-container-headline-30 class=outline-2><h2 id=headline-30>Type Systems</h2><div id=outline-text-headline-30 class=outline-text-2><p>Each program $e$ has a type $t$. Types describe what kind of program $e$ is, i.e. Boolean, Integer, etc. Some programs do not have a type but all programs have at most one type.\\</p><div id=outline-container-headline-31 class=outline-3><h3 id=headline-31>Base types</h3><div id=outline-text-headline-31 class=outline-text-3><p>The base types used in class are only <code class=verbatim>"bool"</code> for boolean and <code class=verbatim>"int"</code> for integer.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>base-ty = &#34;bool&#34; | &#34;int&#34;</code></pre></div></div></div></div><div id=outline-container-headline-32 class=outline-3><h3 id=headline-32>Function types</h3><div id=outline-text-headline-32 class=outline-text-3><p>Type for lambda calculus. Denoted as <code class=verbatim>ty -> ty</code>. The first <code class=verbatim>ty</code> is the input type and the second <code class=verbatim>ty</code> is the output type. Note that both input and output can be functions.</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>ty = base-ty | ty -&gt; ty</code></pre></div></div></div></div><div id=outline-container-headline-33 class=outline-3><h3 id=headline-33>Full simple types examples</h3><div id=outline-text-headline-33 class=outline-text-3><p><code class=verbatim>true</code> has type <code class=verbatim>bool</code><br><code class=verbatim>42</code> has type <code class=verbatim>int</code><br><code class=verbatim>plusOne = \lambda x. x + 1</code> has type =int -> int</p></div></div><div id=outline-container-headline-34 class=outline-3><h3 id=headline-34>Typing context</h3><div id=outline-text-headline-34 class=outline-text-3><p>Type depends on types of free variables in open terms. This kind of types are tracked in a typing context $G$</p><dl><dt>binding</dt><dd><p>$(x : t)$ means variable $x$ has type $t$</p></dd></dl><p>A typing context is a list of bindings. For example, A two-binding context $G$ is $G = x : bool, y : int$. Empty context is denoted as $G = \cdot$.</p></div></div><div id=outline-container-headline-35 class=outline-3><h3 id=headline-35>Together</h3><div id=outline-text-headline-35 class=outline-text-3><p>$G \vdash e : t$ means program $e$ has type $t$ in context $G$.</p><dl><dt>Unicity of Typing</dt><dd><p>For every typing context $G$ and expression $e$, there exists at most one type $t$ such that $G \vdash e : t$.</p></dd><dt>Inversion for Typing</dt><dd><p>Suppose that $G \vdash e :t$. If $e = \mathrm{add}(e_1, e_2)$, then $t = int, G \vdash e_1 : int$, and $G \vdash e_2 : int$.</p></dd></dl></div></div></div></div><div id=outline-container-headline-36 class=outline-2><h2 id=headline-36>Typeclasses <sup class=footnote-reference><a id=footnote-reference-3 href=#footnote-3>3</a></sup></h2><div id=outline-text-headline-36 class=outline-text-2><div id=outline-container-headline-37 class=outline-3><h3 id=headline-37>Define a Typeclass</h3><div id=outline-text-headline-37 class=outline-text-3><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>class</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>Typeclass</span> name<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>instance</span> types<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>where</span>
  <span style=color:#f92672>&lt;</span>function <span style=color:#66d9ef>type</span> prototype here<span style=color:#f92672>&gt;</span></code></pre></div></div><p>Note that the keyword <code class=verbatim>class</code> here is different from the <code class=verbatim>class</code> in object-oriented languages.</p><dl><dt>instance type</dt><dd><p>type that implements the functions defined in the typeclass</p></dd></dl><p>For example:</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>BasicEq</span> a <span style=color:#66d9ef>where</span> <span style=color:#75715e>-- the a is chosen arbitrary</span>
  isEqual <span style=color:#f92672>::</span> a <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Bool</span> <span style=color:#75715e>-- defines one funciton</span></code></pre></div></div><div id=outline-container-headline-38 class=outline-4><h4 id=headline-38>Interpret the type of a typeclass</h4><div id=outline-text-headline-38 class=outline-text-4><p>The type of <code class=verbatim>isEqual</code> is</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>isEqual</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>BasicEq</span> a <span style=color:#f92672>=&gt;</span> a <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Bool</span></code></pre></div></div><p><code class=verbatim>=></code> is a type class constraint. The type of <code class=verbatim>isEqual</code> means if a is an instance of <code class=verbatim>BasicEq</code>, then <code class=verbatim>isEqual</code> takes two <code class=verbatim>a</code> as parameters and return a <code class=verbatim>Bool</code>.</p></div></div></div></div><div id=outline-container-headline-39 class=outline-3><h3 id=headline-39>Define an instance</h3><div id=outline-text-headline-39 class=outline-text-3><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>instance</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>Typeclass</span> name<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>type</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>where</span>
  <span style=color:#f92672>&lt;</span>functions here<span style=color:#f92672>&gt;</span></code></pre></div></div><p>For example</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>BasicEq</span> <span style=color:#66d9ef>Bool</span> <span style=color:#66d9ef>where</span>
  isEqual <span style=color:#66d9ef>True</span> <span style=color:#66d9ef>True</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
  isEqual <span style=color:#66d9ef>False</span> <span style=color:#66d9ef>False</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
  isEqual <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>_</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span></code></pre></div></div><p>Now, <code class=verbatim>isEqual</code> works for <code class=verbatim>Bool</code>, but not for any other types since there is no <code class=verbatim>instance</code> created for other types. The compiler does not know how to compare types other than <code class=verbatim>Bool</code></p></div></div></div></div><div id=outline-container-headline-40 class=outline-2><h2 id=headline-40>Review I</h2><div id=outline-text-headline-40 class=outline-text-2><div id=outline-container-headline-41 class=outline-3><h3 id=headline-41>Haskell</h3><div id=outline-text-headline-41 class=outline-text-3><div id=outline-container-headline-42 class=outline-4><h4 id=headline-42>Function</h4><div id=outline-text-headline-42 class=outline-text-4><ul><li><p>Multiple arguments, Anonymous Functions (\x -> x + 1)</p></li></ul></div></div><div id=outline-container-headline-43 class=outline-4><h4 id=headline-43>Recursions</h4><div id=outline-text-headline-43 class=outline-text-4><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>f</span> <span style=color:#f92672>::</span> [a] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> [a]
<span style=color:#a6e22e>f</span> list times <span style=color:#f92672>=</span> concat <span style=color:#f92672>$</span> map dup list
               <span style=color:#66d9ef>where</span> dup <span style=color:#ae81ff>0</span> x <span style=color:#f92672>=</span> <span style=color:#66d9ef>[]</span>
       dup times x <span style=color:#f92672>=</span> x <span style=color:#66d9ef>:</span> dup (times <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) x</code></pre></div></div></div></div><div id=outline-container-headline-44 class=outline-4><h4 id=headline-44>Higher older function</h4><div id=outline-text-headline-44 class=outline-text-4><div id=outline-container-headline-45 class=outline-5><h5 id=headline-45>.</h5><div id=outline-text-headline-45 class=outline-text-5><p>(a -> b) -> (b -> c) -> (a -> c)
function composition</p></div></div><div id=outline-container-headline-46 class=outline-5><h5 id=headline-46>$</h5><div id=outline-text-headline-46 class=outline-text-5><p>function application</p><ul><li><p>map</p></li><li><p>foldr</p></li><li><p>zip</p></li></ul></div></div></div></div><div id=outline-container-headline-47 class=outline-4><h4 id=headline-47>Curry</h4><div id=outline-text-headline-47 class=outline-text-4><p>((a, b) -> c) -> a -> b -> c</p></div></div><div id=outline-container-headline-48 class=outline-4><h4 id=headline-48>Types</h4><div id=outline-text-headline-48 class=outline-text-4><p>(newtype, data (most powerful), type (least powerful))</p><ul><li><p><code class=verbatim>type</code> has to use with existed type</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Dollar</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Int</span></code></pre></div></div></li><li><p><code class=verbatim>newtype</code> only has one field</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>newtype</span> <span style=color:#66d9ef>AppendList</span> a  <span style=color:#f92672>=</span> <span style=color:#66d9ef>AList</span> ([a] <span style=color:#f92672>-&gt;</span> [a])</code></pre></div></div></li><li><p><code class=verbatim>data</code> could be anything. Like a tree, node, etc.</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Tree</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Leaf</span> a <span style=color:#f92672>|</span> <span style=color:#66d9ef>Node</span> <span style=color:#66d9ef>Left</span> <span style=color:#66d9ef>Mid</span> <span style=color:#66d9ef>Right</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>Child</span> [a] <span style=color:#f92672>|</span> <span style=color:#66d9ef>Empty</span></code></pre></div></div></li></ul></div></div><div id=outline-container-headline-49 class=outline-4><h4 id=headline-49>Typeclasses / subclasses</h4><div id=outline-text-headline-49 class=outline-text-4><div id=outline-container-headline-50 class=outline-5><h5 id=headline-50>Functors</h5><div id=outline-text-headline-50 class=outline-text-5><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>Functor</span> m
  pure <span style=color:#f92672>::</span> a <span style=color:#f92672>-&gt;</span> m a
  pure a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> a
  fmap (a <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> m a <span style=color:#f92672>-&gt;</span> m b
  <span style=color:#75715e>-- &lt;$&gt; is fmap</span>
  fmap f m <span style=color:#f92672>=</span> <span style=color:#66d9ef>case</span> m <span style=color:#66d9ef>of</span>
         <span style=color:#66d9ef>Nothing</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Nothing</span>
  <span style=color:#66d9ef>Just</span> val <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Just</span> <span style=color:#f92672>$</span> f val</code></pre></div></div><ul><li><p>Applicative</p></li></ul><ul><li><p>Monads</p><ul><li><p>IO Monads</p></li></ul></li></ul></div></div></div></div></div></div><div id=outline-container-headline-51 class=outline-3><h3 id=headline-51>Theory</h3><div id=outline-text-headline-51 class=outline-text-3><ul><li><p>Syntax</p><ul><li><p>digit = 0 | 1 | 2 | 3 …
exp = num + exp | exp</p></li></ul></li><li><p>Lambdas Calculus (Not-typed)</p></li><li><p>Semantics (small-step)</p></li><li><p>Type theory (add safety = progress(can step) + preservation(step to same type))</p></li><li><p>Bigger Types (P × Q, P + Q)</p></li></ul></div></div></div></div><div id=outline-container-headline-52 class=outline-2><h2 id=headline-52>Rust Language</h2><div id=outline-text-headline-52 class=outline-text-2><p>[[./TRPL.html][Notes on The Rust Programming Language]</p></div></div><div id=outline-container-headline-53 class=outline-2><h2 id=headline-53>References and Borrowing</h2><div id=outline-text-headline-53 class=outline-text-2><ul><li><p>References is an indirect name for some data. Similar to a pointer to some data.</p></li><li><p>Reference does not own the data.</p><ul><li><p>Can have only one owner, but many references.</p></li></ul></li><li><p>Reference going out of scope does not drop data.</p><ul><li><p>Can "borrow" reference to function</p></li></ul></li><li><p>Function can take (mutable) reference and modify caller's data directly</p><ul><li><p>Useful for mutable datastructures.</p></li></ul></li><li><p>Reference themselves are on stack.</p></li><li><p>By default, references are immutable.</p><ul><li><p>Can't change underlying data through references.</p></li><li><p>Reference type: <code class=verbatim>&T</code></p></li></ul></li><li><p>Can declare mutable references</p><ul><li><p>Target must be mutable as well</p></li><li><p>Reference type: <code class=verbatim>&mut T</code></p></li></ul><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> must my_str <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;foo&#34;</span>); <span style=color:#75715e>// mutable var
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> ref_to_str <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> my_str; <span style=color:#75715e>// mutable ref to my_str
</span></code></pre></div></div></li></ul><div id=outline-container-headline-54 class=outline-3><h3 id=headline-54>Dereferencing</h3><div id=outline-text-headline-54 class=outline-text-3><ul><li><p>Use <code class=verbatim>*</code> notation to get thing reference is pointing at</p></li><li><p>Often not needed due to "auto-deref" (magic)</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> vr: <span style=color:#66d9ef>&amp;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> ...;
println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;First element: {}&#34;</span>, (<span style=color:#f92672>*</span>vr)[<span style=color:#ae81ff>0</span>]); <span style=color:#75715e>// Explicit deref
</span><span style=color:#75715e></span>println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;First element: {}&#34;</span>, vr[<span style=color:#ae81ff>0</span>]);    <span style=color:#75715e>// Implicit deref
</span><span style=color:#75715e></span>println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;First element: {}&#34;</span>, vr.first); <span style=color:#75715e>// Implicit deref
</span></code></pre></div></div></li></ul></div></div><div id=outline-container-headline-55 class=outline-3><h3 id=headline-55>Somewhat confusingly</h3><div id=outline-text-headline-55 class=outline-text-3><p>Reference itself can be mutable</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// Can&#39;t change ref or thing it&#39;s pointing at
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> immut_ref_to_immut <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>my_string;
<span style=color:#75715e>// Can&#39;t change ref, can change thing it&#39;s pointing at
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> immut_ref_to_mut <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> my_string;

<span style=color:#75715e>// Can change ref, can&#39;t change thing it&#39;s pointing at
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> mut_ref_to_immut <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>my_string;
mut_ref_to_immut <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>my_other_string;

<span style=color:#75715e>// Can change ref and thing it&#39;s poing at
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> mut_ref_to_mut <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> my_string;
mut_ref_to_mut <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> my_other_string;
<span style=color:#f92672>*</span>mut_ref_to_mut <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;???&#34;</span>);</code></pre></div></div></div></div><div id=outline-container-headline-56 class=outline-3><h3 id=headline-56>What's going one</h3><div id=outline-text-headline-56 class=outline-text-3><ul><li><p>Mutability is not a property of the data!</p><ul><li><p>Not: these bits are mutable or immutable</p></li></ul></li><li><p>Mutability is property of variable or reference</p><ul><li><p>YES: I can mutate data through this variable</p></li><li><p>YES: I cannot mutate data through that reference</p></li></ul></li></ul></div></div><div id=outline-container-headline-57 class=outline-3><h3 id=headline-57>Multiple References</h3><div id=outline-text-headline-57 class=outline-text-3><ul><li><p>Rust works hard to ensure one owner for each data</p></li><li><p>Multiple references to same data is problematic</p><ul><li><p>Also known as aliasing</p></li></ul></li><li><p>References need to follow certain rules for safty</p></li><li><p>In any scope, there can be either:</p><ol><li><p>Any number of immutable references referring to the same variable</p></li><li><p>At most one mutable reference referring to the same variable</p></li></ol></li></ul></div></div><div id=outline-container-headline-58 class=outline-3><h3 id=headline-58>Multiple Immutable</h3><div id=outline-text-headline-58 class=outline-text-3><ul><li><p>Can have any number of immutable references to variable</p></li><li><p>Safe: none of the references can change the underlying</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> my_str <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;foo&#34;</span>);
<span style=color:#66d9ef>let</span> ref_one <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>my_str;
<span style=color:#66d9ef>let</span> ref_two <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>my_str;

println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Both refs: {} {}&#34;</span>, ref_one, ref_two); <span style=color:#75715e>// OK
</span></code></pre></div></div></li></ul></div></div><div id=outline-container-headline-59 class=outline-3><h3 id=headline-59>At Most One Mutable</h3><div id=outline-text-headline-59 class=outline-text-3><ul><li><p>Can only change underlying through single reference</p><ul><li><p>Also important in concurrent setting</p></li><li><p>Also enables more optimizations</p></li></ul><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> mut_str <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;foo&#34;</span>);
<span style=color:#66d9ef>let</span> ref_one <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> mut_str; <span style=color:#75715e>// OK
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> ref_two <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> mut_str; <span style=color:#75715e>// Not OK
</span></code></pre></div></div></li></ul></div></div><div id=outline-container-headline-60 class=outline-3><h3 id=headline-60>Use Scopes to Manage References</h3><div id=outline-text-headline-60 class=outline-text-3><p>Rules only apply to references currently in scope.</p><div class="src src-rust"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> mut_str <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;foo&#34;</span>);
<span style=color:#66d9ef>let</span> mut_ref <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> mut_str;
mut_ref.push(<span style=color:#e6db74>&#34;bar&#34;</span>); <span style=color:#75715e>// OK
</span><span style=color:#75715e></span>mut_str.push(<span style=color:#e6db74>&#34;baz&#34;</span>); <span style=color:#75715e>// Not OK
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Use scopes!
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> mut_str <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;foo&#34;</span>);
{
    <span style=color:#66d9ef>let</span> mut_ref <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> mut_str;
    mut_ref.push(<span style=color:#e6db74>&#34;bar&#34;</span>); <span style=color:#75715e>// OK
</span><span style=color:#75715e></span>}
mut_str.push(<span style=color:#e6db74>&#34;baz&#34;</span>); <span style=color:#75715e>// OK
</span></code></pre></div></div></div></div><div id=outline-container-headline-61 class=outline-3><h3 id=headline-61>Alternative Reading</h3><div id=outline-text-headline-61 class=outline-text-3><ul><li><p>Immutable reference shared reference</p><ul><li><p>Shared access to some data</p></li><li><p>Sharing: can't change the data</p></li></ul></li><li><p>Mutable reference: unique reference</p><ul><li><p>Exclusive access to some data</p></li><li><p>Can modify it: no one else has access</p></li></ul></li><li><p>Can't mix shared and unique!</p></li></ul></div></div><div id=outline-container-headline-62 class=outline-3><h3 id=headline-62>Isn't a Reference Just a Pointer?</h3><div id=outline-text-headline-62 class=outline-text-3><ul><li><p>In machine code: a reference is just a pointer</p></li><li><p>In Rust: a reference also gives <strong>permissions</strong> to do things</p></li><li><p>With an immutable reference, code can</p><ul><li><p>Dereference/read location</p></li><li><p>Point to/read <strong>anything reachable</strong> from reference.</p></li></ul></li><li><p>With an mutable reference, code can</p><ul><li><p>Dereference/read/write location</p></li><li><p>Point to/read/write <strong>anything reachable</strong> from reference.</p></li></ul></li></ul></div></div><div id=outline-container-headline-63 class=outline-3><h3 id=headline-63>Passing Arguments</h3><div id=outline-text-headline-63 class=outline-text-3><div id=outline-container-headline-64 class=outline-4><h4 id=headline-64>"Moving" Arguments</h4><div id=outline-text-headline-64 class=outline-text-4><ul><li><p>Operationally: arguments passed "by value"</p></li><li><p>Ownership of argument passes into the function</p><ul><li><p>Caller can't use arguments after calling!</p></li><li><p>Arguments moved into function</p></li></ul></li><li><p>Function can return argument to return ownership</p></li></ul></div></div><div id=outline-container-headline-65 class=outline-4><h4 id=headline-65>"Borrowing" Arguments</h4><div id=outline-text-headline-65 class=outline-text-4><ul><li><p>Operationally: arguments passed "by reference"</p></li><li><p>Ownership of argument doesn't change</p><ul><li><p>Original owner (caller, caller-of-caller, …) owns argument.</p></li></ul></li><li><p>Function borrows arguments from the owner</p><ul><li><p>Will give it back to owner when done with it</p></li></ul></li></ul></div></div></div></div><div id=outline-container-headline-66 class=outline-3><h3 id=headline-66>Variables Are Key</h3><div id=outline-text-headline-66 class=outline-text-3><ul><li><p>Anywhere there are variables:</p><ul><li><p>Think about ownership rules</p></li><li><p>Think about borrowing rules</p></li></ul></li></ul></div></div><div id=outline-container-headline-67 class=outline-3><h3 id=headline-67>Matching Can Move Data</h3><div id=outline-text-headline-67 class=outline-text-3><ul><li><p>Often: matching on Enums with data inside</p></li><li><p>The inner data is moved into the match arm</p><ul><li><p>Variable from match arm has ownership</p></li></ul></li><li><p>Typical ownership rules apply</p><ul><li><p>Data is dropped at the end of the arm</p></li></ul></li></ul></div></div><div id=outline-container-headline-68 class=outline-3><h3 id=headline-68>Matching on a reference</h3><div id=outline-text-headline-68 class=outline-text-3><ul><li><p>Rust will infer how to borrow inner values</p><ul><li><p>Matching on <code class=verbatim>&T</code> type: arms borrow immutable</p></li><li><p>Marching on <code class=verbatim>&must T</code> type: arms borrow mutable</p></li></ul></li><li><p>Also called "default binding modes"</p><ul><li><p>Usually: Just work</p></li><li><p>Sometimes; inferences goes wrong (doesn't work)</p></li></ul></li></ul></div></div></div></div><div class=footnotes><hr class=footnotes-separatator><div class=footnote-definitions><div class=footnote-definition><sup id=footnote-1><a href=#footnote-reference-1>1</a></sup><div class=footnote-body><p>The whole note is based on and is coming from the course materials of <a href=https://pages.cs.wisc.edu/~justhsu/teaching/current/cs538/>COMP SCI 538</a> by Professor Justin Hsu.</p></div></div><div class=footnote-definition><sup id=footnote-2><a href=#footnote-reference-2>2</a></sup><div class=footnote-body><p>Notes from Real World Haskell by Bryan O'Sullivan, Don Stewart, and John Goerze</p></div></div><div class=footnote-definition><sup id=footnote-3><a href=#footnote-reference-3>3</a></sup><div class=footnote-body><p>Notes from Real World Haskell by Bryan O'Sullivan, Don Stewart, and John Goerze</p><dl><dt>Typeclasses</dt><dd><p>Typeclasses define a set of functions that can have different implementations depending on the type of data they are given.</p></dd></dl></div></div></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.mrr1vfe.io/tags/haskell/>Haskell</a></li><li><a href=https://www.mrr1vfe.io/tags/rust/>Rust</a></li><li><a href=https://www.mrr1vfe.io/tags/lambda-calculus/>Lambda-Calculus</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Theory and Design of Programming Languages on twitter" href="https://twitter.com/intent/tweet/?text=Theory%20and%20Design%20of%20Programming%20Languages&url=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fcs538%2f&hashtags=Haskell%2cRust%2cLambda-Calculus"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Theory and Design of Programming Languages on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fcs538%2f&title=Theory%20and%20Design%20of%20Programming%20Languages&summary=Theory%20and%20Design%20of%20Programming%20Languages&source=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fcs538%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Theory and Design of Programming Languages on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fcs538%2f&title=Theory%20and%20Design%20of%20Programming%20Languages"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Theory and Design of Programming Languages on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fcs538%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Theory and Design of Programming Languages on whatsapp" href="https://api.whatsapp.com/send?text=Theory%20and%20Design%20of%20Programming%20Languages%20-%20https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fcs538%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Theory and Design of Programming Languages on telegram" href="https://telegram.me/share/url?text=Theory%20and%20Design%20of%20Programming%20Languages&url=https%3a%2f%2fwww.mrr1vfe.io%2fposts%2fcs538%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://www.mrr1vfe.io/>mrr1vfe</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>