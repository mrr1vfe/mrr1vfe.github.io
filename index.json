[{"content":"Notes on Rust in Action, by Tim McNamara\nScientific Notation \\[3.14 \\times 10 ^ 8 \\]\n ::Sign:: representing positive or negative ::Mantissa:: 3.14 ::Radix:: 10 ::Exponent:: 8  Floating Point Computers use scientific notation in memory to represent floating point numbers. A floating number in memory is constitutive of 3 parts\n ::Sign:: ::Mantissa:: ::Exponent:: The ::radix:: is predefined to be 2 and therefore does not need to be stored. The ::sign::, self-evidently, requires only 1 bit.  IEEE 754 Binary32 The leftmost bit, or $b_{31}$ is called the sign bit; the next eight bits are the exponent bits ($b_{23} - b_{30}$); and the last 23 bits are fraction bits ($b_0 - b_{22}$). \\[v = (-1)^\\text{sign} \\times 2^{(exp - 127)} \\times (1 + \\sum_{i=1}^{23} b_{23-i} 2^{-i})\\] When ::sign = 1:: , the number is negative.\nGet the Sign To retrieve the sign bit of a f32 in rust, one first needs to use u32 to represent the bits of the floating number. This process is unsafe and should be placed inside the unsafe block. The function that reinterprets the bits is called transmute.\nlet n: u32 = unsafe { std::mem::transmute(7.7_f32) }; Then, use the bit-wise move operator to move the the bits of n 31 bits to the left.\nlet sign_bit = n \u0026gt;\u0026gt; 31; The left bits will be filled with 0. Since 1 represents negative and 0 represents positive, we would use the exponential function to get the sign (-1 or 1).\nlet sign = (-1_f32).powf(sign_bit as f_32); Get the Exponent Before doing anything, the 8 exponent bits from the floating number has to be retrieved. To achieve this, we move bitwise shift the bits to the left for 23 bits. This way, we have 9 bits left. The leftmost bit is the sign bit and the rest are the exponent bits. The \u0026amp; operator, or bitwise-and operator, allows us to retrieve the bits we want. To get the 8 bits we are interested in, simply \u0026amp; the number with 0xFF. Since 0xFF only has 8 1-bits on the position we are interested in, the non-relevant sign-bit has therefore been filtered out. We call the number we got from this step $n$. Finally, according to IEEE 754, a bias, 127, should be subtracted from the decimal number represented by the 8-bits we got. Then the exponent is going to be $2^{n}$.\nSpecial cases  If $n$ is 0xFF, then the decimal number could be positive infinity, negative infinity (mantissa is 0), or Not a Number (mantissa is anything but 0). These type of numbers are generated from invalid mathematical operations. And comparisons between these number usually do not provide ideal results. If $n$ is 0x00, then the decimal number is a subnormal number. The implicit 24th bit of mantissa is set to be 0.  Get the Mantissa Although there are only 23 bits in f32 left for mantissa. There is an implicit bit that is always 1, which represents the value 1.0, or $2^0$. Then, the $i^{th}$ value, ranging from 22 to 0, represents number $2^{i-23}$, if that bit is set to 1, otherwise 0. The sum of all these number, including the 1.0 of the implicit bit, is the mantissa.\nWe could use the bitwise and operator and the bitwise shift operator in a loop to retrieve the bit value at bit $i$.\nfn main() { let n: u32 = unsafe { std::mem::transmute(0.1_f32) }; let mut mantissa = 0.15625; let base = 2_f32; let mut ad = 1; for i in 0..23 { let bit = n \u0026amp; ad; if bit == 0 { continue; } mantissa += base.powf((i-23) as f32); ad = ad \u0026lt;\u0026lt; 1; } println!(\u0026#34;{}\u0026#34;, mantissa); } ","permalink":"https://www.mrr1vfe.io/posts/decimal-numbers/","summary":"Notes on Rust in Action, by Tim McNamara\nScientific Notation \\[3.14 \\times 10 ^ 8 \\]\n ::Sign:: representing positive or negative ::Mantissa:: 3.14 ::Radix:: 10 ::Exponent:: 8  Floating Point Computers use scientific notation in memory to represent floating point numbers. A floating number in memory is constitutive of 3 parts\n ::Sign:: ::Mantissa:: ::Exponent:: The ::radix:: is predefined to be 2 and therefore does not need to be stored.","title":"Decimal Numbers"},{"content":"Notes on Rust in Action, by Tim McNamara\n All caps If mutable, it’s modifier is static mut, meaning the variable has a mutable static lifetime (valid for the life of the program). If immutable, use const instead.  Code that modify global variable should be placed into an unsafe block. unsafe means as safe as C.\nconst vs. let Although let also defines immutable variable, it defines run time constant. Whereas const defines compile the constant.\n","permalink":"https://www.mrr1vfe.io/posts/global-variables/","summary":"Notes on Rust in Action, by Tim McNamara\n All caps If mutable, it’s modifier is static mut, meaning the variable has a mutable static lifetime (valid for the life of the program). If immutable, use const instead.  Code that modify global variable should be placed into an unsafe block. unsafe means as safe as C.\nconst vs. let Although let also defines immutable variable, it defines run time constant.","title":"Global variables"},{"content":"Notes on Rust in Action, by Tim McNamara\ntype Just an aliasing mechanism. For example, the following code will compile and run:\ntype MyString = String; fn main() { let haha: MyString = String::from(\u0026#34;haha\u0026#34;); let hehe: String = MyString::from(\u0026#34;hehe\u0026#34;); } “new type” struct wrapping If aliasing is not ideal, try this:\nstruct MyString(String); // a tuple Now, the following code will not compile since MyString and String are no longer interchangeable.\nfn main() { let haha: MyString = String::from(\u0026#34;haha\u0026#34;); } 1 | let haha: MyString = String::from(\u0026#34;haha\u0026#34;); | -------- ^^^^^^^^^^^^^^^^^^^^ expected struct `MyString`, found struct `String` methods Use impl block with the name of the struct to declare methods.\nimpl StructName { // todo } Although structs can be initialized using the struct literal, a more common way is to declare a new() methods, as a helper function, to create a new instant of the struct.\nResult Result is an enum, it consists of two variants: Ok(T) and Err(E).\nenum  Works with pattern matching Can have methods Can include data within its variants  trait Similar to an interface, it defines a behavior that struct implemented this trait shall follow. To define a trait, create a block with the trait keyword and the name of the trait. Place method’s name, parameters, and return value only inside the trait block:\ntrait Read { fn read(self: \u0026amp;Self, save_to: \u0026amp;mut Vec\u0026lt;u8\u0026gt;) -\u0026gt; Result\u0026lt;usize, String\u0026gt;; } The Self is a pseudo type, playing as a player holder for the type that will implement this trait To implement a trait, create a block with impl [trait name] for [struct name].\n","permalink":"https://www.mrr1vfe.io/posts/struct-enum/","summary":"Notes on Rust in Action, by Tim McNamara\ntype Just an aliasing mechanism. For example, the following code will compile and run:\ntype MyString = String; fn main() { let haha: MyString = String::from(\u0026#34;haha\u0026#34;); let hehe: String = MyString::from(\u0026#34;hehe\u0026#34;); } “new type” struct wrapping If aliasing is not ideal, try this:\nstruct MyString(String); // a tuple Now, the following code will not compile since MyString and String are no longer interchangeable.","title":"Struct, Enum"},{"content":"Notes on Rust in Action, by Tim McNamara\nArrays  A collection of same thing (type). Size is not changeable. Size is known at compile time. Unlike arrays in Java, arrays in Rust are allocated on stack.  Array initialization  Comma-delimited list within square brackets [8, 9, 6, 4] Repeat expression [5; 10]: An array contains ten 5s.  Type annotation Similar to the repeat expression [type; size], the left hand side is the type of individual element, and the right hand side is the size of the array.\nSlices  Size is not changeable. Size is not known at compile time.  Type annotation Since its size is not known at compile time, there is no size parameter in the type annotation, i.e. [type] only.\nWhy slices? Easy typing. Arrays with the same type of elements but different sizes are considered as different types. Therefore, implementing traits for arrays are harder. On the other hand, since slice does not have size, it is much easier to implement a trait for a type of slice.\nSlice also gives a view to the underlying data.\n Slices can gain fast, read-only access of data without needing to copy anything around\n(similar to numpy array in Python?)\n Vectors  Size is changeable. Has a small runtime penalty that arrays do not have. It’s a vector.  ","permalink":"https://www.mrr1vfe.io/posts/arrays-slices-and-vectors/","summary":"Notes on Rust in Action, by Tim McNamara\nArrays  A collection of same thing (type). Size is not changeable. Size is known at compile time. Unlike arrays in Java, arrays in Rust are allocated on stack.  Array initialization  Comma-delimited list within square brackets [8, 9, 6, 4] Repeat expression [5; 10]: An array contains ten 5s.  Type annotation Similar to the repeat expression [type; size], the left hand side is the type of individual element, and the right hand side is the size of the array.","title":"Arrays, slices, and vectors"},{"content":"Notes on Rust in Action, by Tim McNamara\nCommand line tooling A 3rd party crate called clap is better at handling command line arguments. GitHub - clap-rs/clap: A full featured, fast Command Line Argument Parser for Rust\nuse clap::{App, Arg}; fn main() { let args = App::new(\u0026#34;grep-lite\u0026#34;) .version(\u0026#34;0.1\u0026#34;) .about(\u0026#34;serach for patterns\u0026#34;) .arg( Arg::with_name(\u0026#34;pattern\u0026#34;) .help(\u0026#34;The pattern to search for\u0026#34;) .takes_value(true) .required(true), ) .arg( Arg::with_name(\u0026#34;input\u0026#34;) .help(\u0026#34;File to search\u0026#34;) .takes_value(true) .required(true), ) .get_matches(); let pattern = args.value_of(\u0026#34;pattern\u0026#34;).unwrap(); let input = args.value_of(\u0026#34;input\u0026#34;).unwrap(); } Reading file Need to use to open the file first with File::open() and pass the untapped return value to BufReader::new().\nuse std::fs::File; use std::io::prelude::*; use std::io::BufReader; fn main() { let f = File::open(input).unwrap(); let reader = BufReader::new(f); for line_ in reader.lines() { let line = line_.unwrap(); } } reader.lines() provide a iterator to read lines from the buffered file.\nSTDIN let stdin = io::stdin(); let reader = stdin.lock(); ","permalink":"https://www.mrr1vfe.io/posts/reading-from-user-input/","summary":"Notes on Rust in Action, by Tim McNamara\nCommand line tooling A 3rd party crate called clap is better at handling command line arguments. GitHub - clap-rs/clap: A full featured, fast Command Line Argument Parser for Rust\nuse clap::{App, Arg}; fn main() { let args = App::new(\u0026#34;grep-lite\u0026#34;) .version(\u0026#34;0.1\u0026#34;) .about(\u0026#34;serach for patterns\u0026#34;) .arg( Arg::with_name(\u0026#34;pattern\u0026#34;) .help(\u0026#34;The pattern to search for\u0026#34;) .takes_value(true) .required(true), ) .arg( Arg::with_name(\u0026#34;input\u0026#34;) .help(\u0026#34;File to search\u0026#34;) .takes_value(true) .required(true), ) .get_matches(); let pattern = args.","title":"Reading from user input"},{"content":"Notes on Rust in Action, by Tim McNamara\nNumbers Rust supports operator overloading. Therefore, operators like + can be used on different types, not only numbers (Java does not support it).\nThere is not implicit conversion between types. i32 is always i32 unless otherwise indicated.\nNumbers have methods. But the type of a number must be specified.\nTo print the binary representation of a number, use {:b} as the placeholder for the number.\nComparing numbers Integer Numbers with different types are not comparable. For example, a:i32 cannot be compared to b:i8. A compiler error would raise if one tried to compile the code. To solve this issue, one has to manually cast a number to the type of the other. For example, b as i32 casts b to a i32 number.\nFloating point In Java, 0.1 + 0.2 == 0.3 returns a false due to the idiosyncrasy of how floating numbers are stored in memory. However, the same code returns true in Rust. This is because Rust tolerate some error in floating number. The tolerances are defined as f32::EPSILON and f64::EPSILON. Rust is checking if the absolute difference between two numbers is smaller than the EPSILON value corresponding to the type.\nNot a number in Rust is NAN, which represents undefined numbers result of invalid mathematical operations such. Comparing one NAN to anther NAN value returns false by default.\nRelational, complex and other numbers num create must be used in order to access complex numbers, big integer/decimal numbers, etc.\nIteration Either use \u0026amp; to create a reference of the collection or use iter() method to create a iterator to the collection (Not all types support \u0026amp; referencing. iter() borrows, but into_iter() takes ownership.\nFlow control for for item in collection { // todo } You would want to use a reference if you want to use collection again later.\nfor item in \u0026amp;collection { // todo } Exclusive range: n..m, [n, m) Inclusive range: n..=m, [n, m] If you are not trying to use item, use _ as a placeholder.\nfor _ in 0..10 { // todo } Try not to indexing through a collection. Indexing involves run-time boundary checking, which slows the program. Use a for loop on the collection involves compile-time checking only.\nwhile Does what you expect.\nloop Basically, a while true loop.\ncontinue Does what you expect.\nbreak Does what you expect. It also supports breaking from nested loops. An awkward example:\nuse std::time::{Duration, Instant}; fn main() { let mut age = 58; let mut years_in_office = 0; \u0026#39;presidency: loop { // \u0026#39;{loop_label}:  if age == 82 { let start = Instant::now(); let time_limit = Duration::new(2, 0); loop { if (Instant::now() - start) \u0026lt; time_limit { break \u0026#39;presidency; } } } if years_in_office % 5 == 0 { println!(\u0026#34;连任!\u0026#34;); } age += 1; years_in_office += 1; } } goto No such thing\nif-else If only accepts boolean value. Unlike Java or C/C++, curly braces are required not matter how many statements belong to if/else/for/while.\nConditional expressions return values. Therefore, one can bind (the return value of) a conditional expression to a variable.\nfn main() { let name = if 0 \u0026gt; 1 { \u0026#34;硬点\u0026#34; } else { \u0026#34;钦定\u0026#34; }; println!(\u0026#34;name = {}\u0026#34;, name); } match Match allows you to do pattern-matching. It also informs you if the cases you used is not exhaustive. Similar to if-else, it also returns value.\nfn main() { let speed: u8 = 10; let job = match speed { 0 =\u0026gt; \u0026#34;蜗牛\u0026#34;, 1..=20 =\u0026gt; \u0026#34;乌龟\u0026#34;, 21..=50 =\u0026gt; \u0026#34;兔子\u0026#34;, _ =\u0026gt; \u0026#34;港记\u0026#34;, }; println!(\u0026#34;job = {}\u0026#34;, job); } When match reaches an matched arm, it immediately returns from the matching process.\n","permalink":"https://www.mrr1vfe.io/posts/some-basic-rust/","summary":"Notes on Rust in Action, by Tim McNamara\nNumbers Rust supports operator overloading. Therefore, operators like + can be used on different types, not only numbers (Java does not support it).\nThere is not implicit conversion between types. i32 is always i32 unless otherwise indicated.\nNumbers have methods. But the type of a number must be specified.\nTo print the binary representation of a number, use {:b} as the placeholder for the number.","title":"Some basic Rust"},{"content":"ECE532 ECE539\n","permalink":"https://www.mrr1vfe.io/posts/projects-i-have-done/","summary":"ECE532 ECE539","title":"Projects I have done"},{"content":" Unit 2  Linear Independence and Rank in Learning  Linear independence  A set of $M$ vectors $v_1, v_2, \\cdots, v_m \\in \\mathbb{R}^N$ is linear independent if and only if \\[\\sum^M_{i=1} v_i\\alpha_i = 0 \\Leftrightarrow \\alpha_i = 0, i = 1, 2, \\cdots M.\\] Otherwise, it\u0026#39;s called linearly dependent. A matrix multiplication of $Aw = d$ can be interpreted as the linear combination of the columns of $A$, where the weight for the $i^\\text{th}$ column is the $i^\\text{th}$ element of $w$. So, suppose $A$ is a $3 \\times 2$ matrix where the first column is denoted as $a_1$ and the second column is denoted as $a_2$. Then, we can express $Aw = d$ as $a_1w_1 + a_2w_2 = d$. This $d$ lies in the span of $A$, which includes all vectors that can be written as $\\sum^M_{i=1} a_iw_i$. However, the true value, the value we wish $Aw$ to be, may not lie in the span of $A$. We denote the true value as $\\hat{d}$. In the case that $\\hat{d}$ does not lie in the span of $A$, $\\hat{d} \\neq a_1w_1 + a_2w_2$.\n  Rank of a matrix  The rank of a matrix is the number of linearly independent columns (or rows) that a matrix has. It should be noted that the row rank is equal to the column rank of a matrix. $Rank(A) = n$ means column/row vectors of the matrix can only describe a $n$ dimensional space. There is a relationship between rank of a matrix and solution to a linear system:\n  If $d$ is a linear combination of $a_1, a_2, \\cdots, a_m$, then there is a solution, or $rank(A) = rank([A|d]) \\Leftrightarrow \\text{there is a solution}$\n  So far, it is not clear if there is a solution or infinity many solution\n    If $a_1, a_2, \\cdots, a_m, d$ are linearly independent, then there is no solution, or $rank(A) \u0026lt; rank([A|d]) \\Leftrightarrow \\text{no solution}$\n    Solutions to Learning Problems  It is essential to solve $Aw = d$, in many machine learning problems. Such a solution exists only when $d$ and columns vectors of $A$ are linearly dependent, or, $rank(A) = rank([A|d])$. However, there may be more than one solution (infinity many), which happens if and only if the columns of $A$ are linearly dependent. Hence, the relationship between rank of a matrix and solution to a linear system can be extended to:\n  $rank(A) = rank([A|d]) \\Leftrightarrow \\text{there is a solution}$\n  $rank(A) = dim(w) \\Leftrightarrow \\text{unique solution}$\n  $rank(A) \u0026lt; dim(w) \\Leftrightarrow \\text{infinity many solutions}$\n    $rank(A) \u0026lt; rank([A|d]) \\Leftrightarrow \\text{no solution}$\n  One way to understand that $rank(A) \u0026lt; dim(w)$ implies infinity many solutions is that imagine you have 2 linear equations but 3 variables. One of the variable must be a free one, meaning its value depends on how you set the other two. Hence, there are infinity many solutions.\n    Norm  A norm measures the size of a vector. For example, in the least square problem, we want to find minimize the squared size of the vector $Ax - b$. There are many types of norms, 1-norm, 2-norm, $\\infty-\\text{norm}$, etc. All of these norms can be generalized as a $p-\\text{norm}$: \\[\\norm{x}_p = (\\sum_{i=1}^n |x_i|^p)^{\\frac{1}{p}}.\\] So a 2-norm, or the Euclidean norm, is defined as: \\[\\norm{x}_2 = \\sqrt{\\sum^n_{i=1} x_iw^2}.\\]\n    Unit 3  Singular Value Decomposition  Singular value decomposition (SVD) is a matrix decomposition method that leads to a good low rank approximations. It has a large range of applications.\nDefinition  Every matrix $A \\in \\mathbb{R}^{N \\times M}$ can be factored into \\[A = U \\Sigma V^T\\] where $U \\in \\mathbb{R} ^ {N \\times N}$ is an orthogonal matrix, $\\Sigma \\in \\mathbb{R} ^ {N \\times M}$ is a diagonal matrix, and $V^T \\in \\mathbb{R} ^ {M \\times M}$ is also an orthogonal matrix. Columns of $U$ are called the left singular vectors of $A$; rows of $V^T$, or columns of $V$ are called the right singular vectors of $A$. Values on the main diagonal of $\\Sigma$ are called singular values, denoted as $\\sigma_i$, where $i \\in [1, min(M, N)}]$. A property of singular values is that \\[ \\sigma_i \\geq \\sigma_j \\geq 0, \\forall i \u0026lt; j.\\]\n  Skinny SVD  If $A \\in \\mathbb{R}^{N \\times M}, N \u0026gt; M$, then $\\Sigma \\in \\mathbb{R} ^ {N \\times M}$. Since $N \u0026gt; M$, there are $M$ singular values $\\sigma$. The rest of the entries in $\\Sigma$ are zero. This way, $\\Sigma$ can be partitioned into two matrices:\n  row $1$ to row $M$\n  row $M + 1$ to row $N$\n  Since the the second part is a zero matrix, the result of $U\\Sigma$ is determined by the first $M$ columns of $U$ and the first part of $\\Sigma$. Hence, we can shrink the singular value decomposition of $A$ into: A = U Σ V^T \\quad s.t. \\quad U ∈ \\mathbb{R} ^ {N × M}, Σ ∈ \\mathbb{R} ^ {M × M}, V^T ∈ \\mathbb{R} ^ {M × M}. This SVD is called the skinny, or economic SVD of $A$. Similarly, if $N \u0026lt; M$, then the skinny SVD of $A$ is \\[A = U \\Sigma V^T \\quad s.t. \\quad U \\in \\mathbb{R} ^ {M \\times M}, \\Sigma \\in \\mathbb{R} ^ {N \\times N}, V^T \\in \\mathbb{R} ^ {N \\times M}.\\]\n  Low Rank Approximation with SVD  Given a SVD of a matrix $A$, $A$ can also be written as the sum of outer products of singular vectors: \\[A = \\sum^{M}_{i = 1} \\sigma_iu_iv_i^T.\\] Each $\\sigma_iu_iv_i^T$ here is an rank-1 approximation of the orginal matrix $A$. $u_i$ could be seen as a combination of columns of A, $v^T_i$ could be seen as a combination of rows of A, and $\\sigma_i$ indicates the importance of $u_iv^T_i$. Since, natually, $\\sigma_i$ are given in order, $\\sigma_1u_1v_1^T$ is the best rank-1 approximiation. According to Eckart-Young Theorem, the best rank $k$ approximation of matrix $A$, whose rank is $r \u0026gt; k$, is $\\sum^k_{i = 1} \\sigma_i u_i v_i^T$.\n  Forbenius norm   $\\norm{A}^2_F = \\sum^N_{i=1}\\sum^M_{j=1} A_{ij}^2 = \\norm{vec(A)}^2_2$\n    SVD Describes Matrix as an Operator  Given $A \\in \\mathbb{R} ^ {N \\times M}, x \\in \\mathbb{R}^M, y \\in \\mathbb{R}^N$. Let y = Ax = UΣV^Tx = U[Σ (V^Tx)]. $V^Tx$ can be seen as a rotation of operation of $x$. $\\Sigma[V^Tx]$ scales $V^Tx$. Finally, $U$ rotates and raises the dimension of $\\Sigma V^Tx$ into $\\mathbb{R}^N$.\n  Operator norm   $\\norm{A}_2 = \\norm{A}_{op} = max_{x \\neq 0} \\frac{\\norm{Ax}_2}{\\norm{x}_2} = \\sigma_1$\n        Unit 6  Kernel Regression    Why use higher-dimensional feature spaces\n  Reformulate regression in terms of kernels\n  Popular kernels\n  Cautions and considerations\n  Higher dimensional feature spaces extend regression  $d(x) = w_1x$ can only fit a straight line that passes through the origin. However, if we consider $d(x) = w_3x^3 + w_2x^2 + w_1x + w_0$, then a much complex curve can be modeled. Let $x = [x_1 \\quad x_2 \\quad \\cdots \\quad x_M]^T \\in \\mathbb{R}^M$. Consider $d(x) = \\phi^T (x) w$ where $\\phi (x) \\in \\mathbb{R}^P, P \u0026gt; M$. For example, \\[ x = [x_1 \\quad x_2]^T, \\phi^T (x) = [x_1^2 \\quad x_2^2 \\quad \\sqrt{2}x_1x_2 \\quad x_1 \\quad x_2 \\quad 1] \\] Finding w using \u0026#34;training\u0026#34; data $x^i, d^i, i = 1, 2, \\cdots, N$ with \\[ \\min_w \\sum^N_{i=1} (d^i - \\phi^T (x^i) w)^2 + \\lambda \\norm{w}^2_2. \\] We define $d = [d^1 \\quad d^2 \\quad \\cdots \\quad d^N]^T$ and $\\Phi = [\\phi(x^1) \\quad \\phi(x^2) \\quad \\cdots \\quad \\phi(x^N)]^T$ We can obtain $w$ by solving the ridge regression problem, whose closed form solution is \\[ w = (\\Phi^T \\Phi + \\lambda I)^{-1} \\Phi^T d. \\]\n  Regression is a weight sum of \u0026#34;kernels\u0026#34;  $d(x) = \\phi^T (x) w = \\phi^T (x) (\\Phi^T \\Phi + \\lambda I)^{-1} \\Phi^T d$. Note that $(\\Phi^T \\Phi + \\lambda I)^{-1}$ is of size $P \\times P$. By the matrix identity: $(\\Phi^T \\Phi + \\lambda I)^{-1}\\Phi^T = \\Phi^T(\\Phi\\Phi^T + \\lambda I)^{-1}$, $d(x) = \\phi^T (x) \\Phi^T (\\Phi\\Phi^T + \\lambda I)^{-1} d$, with Φ^T (ΦΦ^T + λ I)-1 of size $N \\times N$. Note that \\begin{align*} [Φ Φ ^ T]i, j \u0026amp;= ɸ^T (x^i) ɸ (x^j) [ɸ^T (x) Φ ^ T]j \u0026amp;= ɸ^T (x) ɸ (x^j). \\end{align*} These two equations can be defined to be a kernel \\begin{align*} K(u, v) = ɸ^T (u) ɸ(v). \\end{align*} If $\\alpha = [\\alpha_1 \\quad \\cdots \\quad \\alpha_N]^T = (\\Phi\\Phi^T + \\lambda I)^{-1} d$, then \\[ d(x) = \\sum^N_{i=1} \\alpha_i \\phi^T (x) \\phi(x^i) = \\sum^N_{i = 1} \\alpha_i k(x, x^i). \\]\n  Kernel methods find $d(x)$ without computing $\\phi(x)$  $d(x) = \\sum^N_{i=1} \\alpha_i K(x, x^i)$. Since $\\alpha = (\\Phi\\Phi^T + \\lambda I)^{-1}$, the $\\Phi\\Phi^T$ can also be represented as a kernel and can be computed efficiently.\n  Popular kernels depend on similarity of $u$, $v$  Due to the following formula \\[ u^Tv = \\norm{u}_2\\norm{v}_2 cos\\theta, \\] the closer $u$ and $v$, the larger the result $u^Tv$.\n  Monomials of degree $q$   $K(u, v) = (u^Tv)^q$\n  Polynomials up to degree $q$   $K(u, v) = (u^Tv + 1)^q$\n  Gaussian/radial kernel   $K(u, v) = e^{\\frac{-\\norm{u - v}^2_2}{2 \\sigma^2}}$\n  There is no explicit $\\phi(x)$ for Gaussian kernel since it has infinity dimensions, meaning it can be applied to all polynomial orders. The smoothness of Gaussian kernel is controlled by $\\sigma$.\n  Kernel regression considerations  We should use cross-validation to avoid overfitting with hight dimensional feature spaces.\n      ","permalink":"https://www.mrr1vfe.io/posts/cs532/","summary":"Unit 2  Linear Independence and Rank in Learning  Linear independence  A set of $M$ vectors $v_1, v_2, \\cdots, v_m \\in \\mathbb{R}^N$ is linear independent if and only if \\[\\sum^M_{i=1} v_i\\alpha_i = 0 \\Leftrightarrow \\alpha_i = 0, i = 1, 2, \\cdots M.\\] Otherwise, it\u0026#39;s called linearly dependent. A matrix multiplication of $Aw = d$ can be interpreted as the linear combination of the columns of $A$, where the weight for the $i^\\text{th}$ column is the $i^\\text{th}$ element of $w$.","title":"Matrix Methods in Machine Learning"},{"content":" Basic compilation using GCC  gcc matrix.c  This command outputs a executable binary named a.out, which can be executed in the shell by ./a.out.\n  Name the output binary file  a.out may not be a great name for the your binary, and using mv to rename a file every time after compilation is tedious. The -o flag allows users to name the output binary.\ngcc matrix.c -o matrix  Run the program by ./matrix.\n  Four Steps of compiling a c file to a executable binary    Preprocessing\n  Compiling   Assembly\n  Linking\n  Preprocessing  First step of a compilation process in which header files are swapped in, macros are substituted with its actual value, and conditional compilation is handled. The module which does the preprocessing is called preprocessor (cpp) whose input is a c file and output is a also a c file. To see the output of preprocessor, use the -E flag.\ngcc matrix.c -E -o matrix.i  matrix.i contains the preprocessed code.\n// original code #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; typedef struct matrix_container { int row; int col; int **matrix; } Matrix; // preprocessed code # 422 \u0026#34;/usr/local/Cellar/gcc/10.1.0/lib/gcc/10/gcc/x86_64-apple-darwin19/10. 1.0/include-fixed/stdio.h\u0026#34; 2 3 4# 3 \u0026#34;matrix.c\u0026#34; 2  # 4 \u0026#34;matrix.c\u0026#34; typedef struct matrix_container { int row; int col; int **matrix; } Matrix;  It can be seen that there is no more #include in the preprocessed file.\n  Compiling  Second step of a compilation process. The compiler (cc1) takes a preprocessed c file as an input and outputs a .s assembly program which contains the assembly code of the target machine. For example, my machine has an intel CPU. Therefore, the assembly program generated by the compiler (cc1) is in x86-64 instruction set. Adding the -m32 flag forces the compiler to generate IA-32 assembly code.\ngcc matrix.c -S -o matrix.s  output, content of matrix.s\nL1$pb: subl $12, %esp leal lC0-L1$pb(%ebx), %eax pushl %eax call _puts addl $16, %esp movl $0, -12(%ebp) jmp L2 L5: movl $0, -16(%ebp) jmp L3 L4: movl 8(%ebp), %eax    Assembling  The assemblar (as) converts the assembly program to the relocatable object program, which is a binary but non-executable file. The reason why the binary cannot be executed is that assembly code for functions like printf() that is not written by you is not included.\ngcc matrix.c -c -o matrix.o    Linking  The linker (ld) gathers all relocatable files and combines them into a single executable binary file. It takes relocatable object files as input and output the final executable binary. It can be seen that the output of linker is larger than the output of assemblar, which does not include binary of other relocatable object files. There is no special flag for the linker. matrix, the executable binary, is larger than matrix.o (13128 \u0026gt; 3772).\n-rwxr-xr-x 1 yichen 13128 Jul 30 23:32 matrix -rw-r--r-- 1 yichen 3772 Jul 31 02:49 matrix.o      Other flags  -Wall  Output all warnings. If I introduce a unused variable\nint main(void) { Matrix *matrices[2]; for (int i = 0; i \u0026lt; 2; i++) matrices[i] = create_matrix(); Matrix *result = multiply_matrix(matrices[0], matrices[1]); print_matrix(result); Matrix *mat; // unused variable  free_matrix(result); free_matrix(matrices[0]); free_matrix(matrices[1]); return 0; }  compiling without -Wall flag, GCC does not have any output\n➜ matrix_hw gcc-10 matrix.c -o matrix ➜ matrix_hw  compiling with -Wall flag, GCC outputs a warning message\n➜ matrix_hw gcc-10 matrix.c -o matrix -Wall matrix.c: In function \u0026#39;main\u0026#39;: matrix.c:106:13: warning: unused variable \u0026#39;mat\u0026#39; [-Wunused-variable] 106 | Matrix *mat; | ^~~    -D  -D [marco name]=[marco value] is equivalent to adding #define [marco name]=[macro value] to the source code.\nint main(void) { Matrix *matrices[SIZE]; for (int i = 0; i \u0026lt; SIZE; i++) matrices[i] = create_matrix(); Matrix *result = multiply_matrix(matrices[0], matrices[1]); print_matrix(result); free_matrix(result); free_matrix(matrices[0]); free_matrix(matrices[1]); return 0; }  The source code does not define SIZE. Hence, compiling without -D flag results an error.\nmatrix.c: In function \u0026#39;main\u0026#39;: matrix.c:99:22: error: \u0026#39;SIZE\u0026#39; undeclared (first use in this function) 99 | Matrix *matrices[SIZE]; | ^~~~ matrix.c:99:22: note: each undeclared identifier is reported only once for each function it appears in  Using the -D flag.\ngcc-10 matrix.c -o matrix -D SIZE=2    -I  -I [dir] adding extra header directory. GCC finds header files in the current directory or in usr/include/. Compiling the source code that includes header file that is in other directory results an error.\n#include \u0026#34;matrix_op.h\u0026#34;#define SIZE 2  int main(void) { Matrix *matrices[SIZE]; for (int i = 0; i \u0026lt; SIZE; i++) matrices[i] = create_matrix(); Matrix *result = multiply_matrix(matrices[0], matrices[1]); print_matrix(result); free_matrix(result); free_matrix(matrices[0]); free_matrix(matrices[1]); return 0; }  matrix_op.h is not in . nor usr/include. It is in ./include.\n➜ matrix_hw ls include matrix matrix.c ➜ matrix_hw ls include matrix_op.h  Compile the code results an error.\n➜ matrix_hw gcc-10 matrix.c matrix_op.c -o matrix matrix.c:1:10: fatal error: matrix_op.h: No such file or directory 1 | #include \u0026#34;matrix_op.h\u0026#34; | ^~~~~~~~~~~~~ compilation terminated. matrix_op.c:3:10: fatal error: matrix_op.h: No such file or directory 3 | #include \u0026#34;matrix_op.h\u0026#34; | ^~~~~~~~~~~~~ compilation terminated.  To compile it, add -I [header dir].\nmatrix_hw gcc-10 matrix.c matrix_op.c -o matrix -I./include    -g  With -g, GCC compiles code with debug information, which is helpful when using debugger like GDB or LLDB. Setting breakpoints using filename and line number in LLDB, with binary that compiled without -g flag.\n(lldb) b matrix.c:9 Breakpoint 1: no locations (pending). WARNING: Unable to resolve breakpoint to any actual locations.  Setting breakpoints using filename and line number in LLDB, with binary that compiled with -g flag.\n(lldb) b matrix.c:9 Breakpoint 1: where = matrix`main + 48 at matrix.c:9:22, address = 0x0000000100000724  It is more easier to debug, setting breakpoints, for example, with binary that compiled with -g flag.\n    Optimization  To see the optimization results, I wrote a program that does matrix multiplication of different size of matrices. Each run of the program is going to output the time it takes to finish the job. Then, I use a python script to run the program for 100 times, and calculate the mean, standard deviation, and total time. Since $N = 100$ is greater than 30, the sampling distribution is normal.\n   Flag Average time (sec) Standard Deviation Compilation Time     None 0.55726 0.035869 0.195   -O 0.200644 0.006497 0.212   -O2 0.079052 0.002817 0.286   -O3 0.077760 0.003685 0.477    It can be seen that program compiled with -O flag is running significantly faster than program compiled without optimization flag. And program compiled with -O2 is running significantly faster than program compiled with -O1 flag. Moreover, the compilation time increases as more optimizations are applied.\nSignificance test on the running time difference between the program compiled with -O2 and -O3  Test at $\\alpha = 0.01$ \\begin{align*} H_0: μ_1 = μ_2 H_1: μ_1 \u0026gt; μ_2 \\end{align*} where $\\mu_1$ is the true mean of running time of program compiled with -O2 flag and $\\mu_2$ is the true mean of running time of program compiled with -O3 flag.\n \\begin{align*} z \u0026amp;= \\frac{\\bar{x_1} - \\bar{x_2}}{\\sqrt{\\frac{σ^2_1}{n_1} + \\frac{σ^2_2}{n_2}}}\n\u0026amp;= \\frac{0.079052 - 0.077760}{\\sqrt{\\frac{0.002817^2}{100} + \\frac{0.003685^2}{100}}} \u0026amp;=\t\\frac{0.001292}{0.000464} \u0026amp;= 2.78 \\end{align*} Since $z = 2.78$ is greater than 2.575, we reject the $H_0$. There is enough evidence showing that the matrix program compiled with -O3 flag has significant shorter running time than the program compiled with -O2 flag.\n  Code, Script, and Results  Test code:\nstruct timeval tic, toc; gettimeofday(\u0026amp;tic, NULL); for (int i = 0; i \u0026lt; 100; i++) { Matrix *A = dummy_matrix(i, i * 5); Matrix *B = dummy_matrix(i * 5, i); multiply_matrix(A, B); free_matrix(A); free_matrix(B); } gettimeofday(\u0026amp;toc, NULL); printf(\u0026#34;%lu\u0026#34;, (toc.tv_sec - tic.tv_sec) * 1000000 + toc.tv_usec - tic.tv_usec);  Test script:\nimport os import math import subprocess N = 100 results = [] for i in range(0, N): result = subprocess.check_output(\u0026#39;./matrix\u0026#39;, shell=True) result = int(result) / 1000000 results.append(result) TOTAL = sum(results) MEAN = TOTAL / N def process(x): return (x - MEAN) ** 2 VAR = sum(list(map(process, results))) / N SD = math.sqrt(VAR) print(\u0026#34;-\u0026#34; * 10, \u0026#34;Result\u0026#34;, \u0026#34;-\u0026#34; * 10) print(\u0026#34;n = %d, sum = %f\u0026#34; % (N, TOTAL)) print(\u0026#34;mean = %f\u0026#34; % MEAN) print(\u0026#34;standard deviation = %f\u0026#34; % SD) print(results)  Result without optimization flag\n---------- Result ---------- n = 100, sum = 55.726015 mean = 0.557260 standard deviation = 0.035869  Result with -O flag\n---------- Result ---------- n = 100, sum = 20.064405 mean = 0.200644 standard deviation = 0.006497  Result with -O2 flag\n---------- Result ---------- n = 100, sum = 7.905217 mean = 0.079052 standard deviation = 0.002817  Result with -O3 flag\n---------- Result ---------- n = 100, sum = 7.776048 mean = 0.077760 standard deviation = 0.003685      Different ways of performing matrix multiplication  1\njki  for (int j = 0; j \u0026lt; B-\u0026gt;col; j++) { for (int k = 0; k \u0026lt; B-\u0026gt;row; k++) { int r = B-\u0026gt;matrix[k][j]; for (int i = 0; i \u0026lt; A-\u0026gt;row; i++) { C-\u0026gt;matrix[i][j] += A-\u0026gt;matrix[i][k] * r; } } }  This program has the worst performance since it has the worst spatial locality. Suppose the cache can only hold a row of the matrix. Each inner iteration of the innermost loop would lead to a cache miss since; each iteration of the second-most-inner loop too would lead to a cache miss. A cache miss requires CPU to fetch data from memory via bus, which is time consuming comparing to using cache data.\n  kij  for (int k = 0; k \u0026lt; A-\u0026gt;col; k++) { for (int i = 0; i \u0026lt; C-\u0026gt;row; i++) { int r = A-\u0026gt;matrix[i][k]; for (int j = 0; j \u0026lt; B-\u0026gt;col; j++) { C-\u0026gt;matrix[i][j] += r * B-\u0026gt;matrix[k][j]; } } }  This way of performing matrix multiplication has the best performance since the stride size is smaller and the program takes the advantages of both spatial and temporal locality.\n  ijk  for (int i = 0; i \u0026lt; C-\u0026gt;row; i++) { for (int j = 0; j \u0026lt; C-\u0026gt;col; j++) { for (int k = 0; k \u0026lt; A-\u0026gt;col; k++) { C-\u0026gt;matrix[i][j] += A-\u0026gt;matrix[i][k] * B-\u0026gt;matrix[k][j]; } } }  This program has the moderate performance.   Comparison  Here is a plot comparing the average task completion time of 50 runs of each ways of performing matrix multiplication. It can be seen that generally, kij has the best performance. It advantage is especially notable when the dimension of matrix is increasing, as more L1 cache is used.     Different optimization flags on different sizes of matrix  The plot indicates that -03 has the best performance over all the other optimization rules. As the dimension of the matrix involved in the multiplication process increases, the advantage of -O3 is more noticeable. The reason that -O3 has the best performance is that -O3 attempts to vectorize loops, which are used abundantly in the operation of matrix multiplication. It uses more advanced instruction set that has better arithmetic performance. It can be seen from the following image that -O2 flag together with ftree-vectorize achieve the similar performance of -O3. This phenomenon indicates that vectorization has a great impact on program\u0026#39;s performance. Moreover, according to GCC, line 112 is optimized.\n➜ code gcc-10 matrix_op.c main.c -o matrix_vec -ftree-vectorize -O2 -mavx -fopt-info-vec-optimized matrix_op.c:112:3: optimized: loop vectorized using 16 byte vectors matrix_op.c:112:3: optimized: loop versioned for vectorization because of possible aliasing  This line is corresponding to the following C code\nfor (int j = 0; j \u0026lt; B-\u0026gt;col; j++)  Which is an essential part to the matrix multiplication.\n  -ftree-vectorize  As mentioned above, the most significant optimization in -O3 for the program is -ftree-vectorize. Roughly speaking, when -ftree-vectorize is activated, GCC will try to convert normal loop into loop that utilizes SIMD built-in functions. The tree-vectorizer is going to analyze the loops and then transform the vectorizable loops into the designated form. Each loop and each statement in will be attached by loop_vec_info and stmt_vec_info. When transforming loop, the program is going to scan every statements inside the loop and create a corresponding vector for everything needed to be vectorized.\n  1 https://blog.csdn.net/haolexiao/article/details/65936158\n    ","permalink":"https://www.mrr1vfe.io/posts/matrix/","summary":"Basic compilation using GCC  gcc matrix.c  This command outputs a executable binary named a.out, which can be executed in the shell by ./a.out.\n  Name the output binary file  a.out may not be a great name for the your binary, and using mv to rename a file every time after compilation is tedious. The -o flag allows users to name the output binary.\ngcc matrix.c -o matrix  Run the program by .","title":"Compiling C code using GCC"},{"content":" 构造一个简单的编译器    目标   表达式中缀表示转化成后追表示\n  过程   字符流 -\u0026gt; 词法分析器 -\u0026gt; 单词流 -\u0026gt; 语法制导翻译器 -\u0026gt; 中间表示形式\n  语法制导翻译器   语法分析 + 中间代码生成\n    context-free grammar (CFG)    context-free grammar   For a language L, its CFG defines the sets of strings of symbols that are valid sentences in L.\n  sentence   A string of symbols that can be derived from the rules of a grammar.\n  production   Each rule in a CFG is called a production.\n  nonterminal symbol   A syntactic variable used in a grammar\u0026#39;s production.\n  terminal symbol   Each word in the language defined by the grammar.\n  Backus-Naur Form   BNF denoted nonterminal symbols by wrapping them in angle brackets, and terminal symbols were underlined.\n  Start symbol   Or goal symbol, represents the set of all strings in a language, one of the nonterminal symbols introduced to add structure and abstraction to the language.\n  Language SN \\begin{align*} SheepNoise →\u0026amp; \\text{ baa } SheepNoise \\\\\n   \u0026amp;\t\\text{ baa }    \\end{align*} SheepNoise is a nonterminal symbol. baa is a terminal symbol. 1\n  形式化定义    $\\Sigma$   有穷字母表，元素，符号\n  符号串   $\\Sigma$ 中符号构成的有穷序列\n  空字   不含任何符号的序列, $\\epsilon$\n  $\\Sigma ^ *$   符号串全体，包括空字\n  $\\phi$   空集 {}, 与$\\epsilon$, {}, 和 {$\\epsilon$}不同\n  $\\Sigma ^ *$ 的子集U, V的积 (连接)   $UV$ = {$\\alpha \\beta | \\alpha \\in U, \\beta \\in V$}\n  没有交换律   $UV \\neq VU$\n  结合律   $(UV)W = U(VW)$\n  V自身的n次积（连接）   $V^n$\n  ?   $V^n$ = {ε}\n  V的闭包 (Closure)   $V^*$ = $V^0 \\cup V^1 \\cup V^2 \\cup V^3 \\cup$ …\n  正则闭包   $V^+ = VV^*$\n    四元式定义上下文无关文法    $(V_T, V_N, S, P)$\n  $V_T$   非空有限集，终结符号集合, The set of terminal symbols, or words, in the language $L(G)$.\n  $V_N$   非空有限集，非终结符号集合, The set of nonterminal symbols that appear in the productions of $G$.\n  $S$   开始符号, A nonterminal designated as the goal symbol or start symbol of the grammar. $S$ represents the set of sentences in $L(G)$.\n  $P$   产生式有限集. The set of productions or rewrite rules in $G$. Each rule in $P$ has the form $V_N \\rightarrow (V_T \\cup V_N)^+$.\n      推导    由开始符号作为推导起点, start with a prototype string that contains just the goal symbol.\n  由产生式右部分替换左部非终结符, pick a nonterminal symbol in the prototype string and rewrite it with a nonterminal or terminal symbol that can be converted to according to a production.\n  反复替换，最终得到单词串, repeat this rewriting process until the prototype string contains no more nonterminals, at which point it consists entirely of words, or temrinla symbols, and is a sentence in the language.\n    语法分析树 parse tree    根结点位开始符号\n  每个叶节点用一个 $T$ 或 $\\epsilon$ 标记\n  每个内部节点用一个NT标记\n  节点A的孩子节点位X_1, X_2,…, X_n $\\rightarrow$ (A → X_1 X_2 X_3 …X_n)\n  叶节点从左到右构成数的输出 $\\leftrightarrow$ 开始符号推导出的单词穿\n  运算符的结合律    Left associative   +, -, *, /\n  Right associative   ^, =\n      1 Cooper, K., \u0026amp; Torczon, L. (2011). Engineering a compiler. Elsevier.\n    ","permalink":"https://www.mrr1vfe.io/posts/contex-free-grammar/","summary":"构造一个简单的编译器    目标   表达式中缀表示转化成后追表示\n  过程   字符流 -\u0026gt; 词法分析器 -\u0026gt; 单词流 -\u0026gt; 语法制导翻译器 -\u0026gt; 中间表示形式\n  语法制导翻译器   语法分析 + 中间代码生成\n    context-free grammar (CFG)    context-free grammar   For a language L, its CFG defines the sets of strings of symbols that are valid sentences in L.\n  sentence   A string of symbols that can be derived from the rules of a grammar.","title":"编译器的基本构造"},{"content":" Basic Python, comparing to Java 1    Why are we using python?   It has a large amount of better machine learning libraries.\n  Useful link   Online Python compiler\n  Key differences from Java\t   Do not bother with a class unless you actually want to make an object.\n  Functions do not need return types (or parameter types).\n  Indentations matter, not {}; begin functions with : and end by unindenting.\n  Strings can be inside \u0026#34;\u0026#34; or \u0026#39;\u0026#39;; comments begin with #, and no semicolons are needed.\n  Control flow  Conditions and loops have the same indentation rules as functions. For loops are actually for each loops. Therefore some iterables objects are needed to iterate over (list, string, etc).\n  Operators    There is not ++ operator. Use +=1 instead.\n  is operator is Java\u0026#39;s ==.\n  == operator is Java\u0026#39;s .equals().\n    Reading files  with open(\u0026#39;[filename]\u0026#39;, \u0026#39;[mode]\u0026#39;) as f: # closes automatically when you unindent. for line in f: print(line)    import  import is used to get access to any codes beyond the basic.\nimport math # to get access to some math functions        Think AI at different levels    AI in movies\n  AI in reality\n  AI in \u0026#34;theory\u0026#34;\n  AI implementation\n  Big idea in AI: State space  The search problem is to find a solution path from a state in $I$ to a state in $G$. Optionally minimize the cost of the solution\n  State space   $S$, all valid configurations\n  Initial states   $I \\in S$\n  Goal states   $G \\in S$\n  Successor function   succs($s$) $\\in S$, states reachable in one step from $s$.\n  Cost   cost(path) = $\\sum_{(\\textrm{edge} \\in \\textrm{path})} \\textrm{Cost(edge)}$\n      Hill Climbing  Optimization problems    Each state $s$ has a score $f(s)$ that we can compute.\n  The goal is to find the state with the highest score, or a reasonably high score.\n  Do not care about path.\n  Why?    Hard to know the goal state\n  Hard to know successor state\n  Hard to enumerate\n      Idea  Starting from some state $s$, and move to a neighbor $t$ with better score. Repeat this process.\n  Neighbor   You have to define it, also known as move set. It is similar to successor function.\n  Neighborhood   A set of neighbors of a given state. A neighborhood bust be small enough for efficiency.\n    Neighbor picking  If no neighbor is better than the current state, i.e. $f(s)$ is worse, then do nothing. Otherwise pick the best one (greedy).\n  Algorithm  s = initial_state() # pick the initial state s while True: neighbors = get_neighbors(s) # generate all neighbors best = best_neighbor(neighbor) # pick the neighbor with the best f score if f_score(best) \u0026lt;= f_score(s): return s s = best  This is very greedy. Easily stuck.\n  Local optima in hill climbing  We want global optimum. There can many local optima, which we do not want.\n$s$ is local minimum if $\\forall t \\in \\textrm{succ}(s), f(s) \u0026lt; f(t)$. $s$ is global minimum if $\\forall t \\in S, f(s) \u0026lt; f(t)$\n  Repeated hill climbing with random restarts  When stuck, pick a random new start. run basic hill climbing from there. Repeat this process for $k$ times. Then return the best of the $k$ local optima. This can be very effective, and should be tried whenever hill climbing is used.\n    Basic Probability and Statistics  Great idea: Uncertainty modeled by probability. Probability is the language of uncertainty. It is the central pillar of modern day artificial intelligence.\nSample Space    A space of events that we assign probabilities to.\n  Events can be binary, multi-values, or continuous.\n  Events are mutually exclusive.\n  Examples\n  Coin flip: {head, tail}\n  Die roll: {1, 2, 3, 4, 5, 6}\n  English words: a dictionary\n      Random Variable  A variable, $x$, whose domain is the sample space, and whose value is somewhat uncertain. Examples:\n  x = coin flip outcome\n  x = first word in tomorrow\u0026#39;s headline news\n  x = tomorrow\u0026#39;s temperature\n    Axioms of probability    $P(A) \\in [0, 1]$\n  $P(\\textrm{True}) = 1$, $P(\\textrm{False}) = 0$.\n  $P(A \\cup B) = P(A) + P(B) - P(A \\cap B)$\n    Coin  A coin has 2 sides, head and tail. The probability of getting a head, when flipping a coin, is denoted as $P(H)$, and the probability of getting a tail is $P(T)$. And $P(H) + P(T) = 1$ since getting a head and getting a tail are the only two options, assuming the coin cannot stand. If the a coin is fair, then $P(H) = P(T) = \\frac{1}{2}$. Otherwise, $P(H) = p \\in [0, 1], P(T) = 1 - p$.\n  Law of large numbers  Flip a coin N times, let the outcomes be $x_1 \\in \\{H, T\\}, x_2 \\in \\{H, T\\}, ..., x_N \\in \\{H, T\\}$. There is a indicator function called $\\mathbb{I}$: \\begin{align*} \\mathbb{I}[Z] = \\begin{cases} 1,\u0026amp; \\text{if } Z \\text{ is True}\\\\ 0,\u0026amp; \\text{if } Z \\text{ is False} \\end{cases} \\text{ Where } Z \\text{ is a boolean function} \\end{align*} Then, \\begin{align*} limN → ∞ \\frac{∑^Ni=1\\mathbb{I}[x_i = H]}{N} = p \\end{align*} $p$ is the frequency interpretation of probability.\n  Die  Given a fair die that has 6 faces, the probability of getting each face after a roll is the same, $\\frac{1}{6}$. However, if a die is loaded, or unfair, then the probability of getting each face, $P_1 ... P_6$ is $\\sum^6_{j=1}P_j = 1, P_j \\in [0, 1], j=1...6$. The outcome of a die rolling is $x \\in \\{1, 2, 3, 4, 5, 6\\}$. Then, \\begin{align*} limN → ∞ \\frac{∑^Ni=1\\mathbb{I}[x_i = j]}{N} = p_j \\text{, for } j = 1 … 6 \\end{align*}\n  Joint probability  $P(A, B)$ → Both events $A$ and $B$ are true.\n  Negation (complement)  $\\bar{A} = \\neg A = A^c$ $P(\\bar{A}) = 1 - P(A)$\n  Marginalization  $P(A, B) + P(\\bar{A}, B) = P(B)$\n  Conditional Probability  $P(A|B)$ is the probability of A given B (is observed). \\begin{align*} P(A | B) = \\frac{P(A, B)}{P(B)} = \\frac{P(A, B)}{P(A, B) + P(\\bar{A} + B)} \\end{align*}\nBayes Rule  \\begin{align*} P(F|H) \u0026amp;= \\frac{P(F, H)}{P(H)} P(H|F) \u0026amp;= \\frac{P(H, F)}{P(F)} = \\frac{P(F, H)}{P(F)}\nP(F, H) \u0026amp;= P(H|F)P(F) \\frac{P(F, H)}{P(H)} \u0026amp;= \\frac{P(H|F)P(F)}{P(H)} P(F|H) \u0026amp;= \\frac{P(F, H)}{P(H)} = \\frac{P(H|F)P(F)}{P(H)} \\end{align*}\n    Independence  Two events A, B are independent if:\n  P(A, B) = P(A) * P(B)\n  P(A | B) = P(A)\n  P(B | A) = P(B)\n    Conditional Independence  Random variables can be dependent, but conditionally independent. In general, A, B are conditionally independent given C if\n  P(A|B, C) = P(A | C) or\n  P(B|A, C) = P(B | C) or\n  P(A, B|C) = P(A|C) * P(B|C)\n      Tuning set  To minimize over-fitting, we can use a tuning set.\n  We get a labeled data set $(x_1, y_1) \\cdot \\cdot \\cdot (x_N, y_N)$.\n  Randomly split the data set into 3 sets.\n  First, shuffle those N data items\n  Take some fraction (e.g. 60%) of the shuffled item, and call them training set\n  Take another fraction (e.g. 20%), and call them tuning set\n  The remaining items are test set\n  You want the training set to be large enough, but you also want the tuning set and the test set to be not so small\n    Train $\\hat{\\beta}^{(0)}, \\hat{\\beta}^{(1)}, \\cdot\\cdot\\cdot \\hat{\\beta}^{(n-1)}$ on training set.   Measure their tuning set MSE.\n  Pick the best model, using\n    \\begin{align*} \\hat{j}^* = argminj = 0…n-1 [\\textrm{tuning-set MSE}(\\hat{β}(j))] \\end{align*} where \\begin{align*} \\textrm{tuning-set MSE}(\\hat{β}(j)) = \\textrm{average of }L(x, y, \\hat{β}(j))\\textrm{on tuning points } (x, y) \\end{align*}\n  We pick model $\\hat{\\beta}^{\\hat{j}^*}$\n    We report test-set MSE with model $\\hat{\\beta}^{\\hat{j}^*}$.\n    K nearest neighbor classifier  Recall    Unsupervised Learning, Data: $x_1 \\cdot\\cdot\\cdot x_n$\n  Dimension Reduction\n  Clustering\n      HAC\n  kmeans\n    Supervised, Training Data $(x_i, y_i), i \\in [1, n]$\n  Regression, $y \\in R$\n  Classification, $y$ discrete finite \u0026#34;classes\u0026#34;\n      Naive Bayes\n  KNN\n    KNN algorithm    input 1   $(x_1, y_1) \\cdot\\cdot\\cdot (x_n, y_n),\\textrm{ where } x_i \\in R^d, y_i \\textrm{ is a class label}$\n  input 2   A distance function, $dist(x, x\u0026#39;)$. e.g. Euclidean distance $|x - x\u0026#39;|$\n    Given a new item $x \\in R^d$, find the K nearest neighbors of x in the training set under $dist()$.\n  Predict a label $\\hat{y}$ as the majority label of the K nearest neighbor. (Break tie arbitrarily).\n    Classification vs. Clustering    Terminology    0-1 Loss function   $L(x, y, \\hat{y}) = \\begin{cases} 1, \u0026amp; \\text{if}\\ y \\neq \\hat{y} \\text{ mis-prediction} \\\\ 0, \u0026amp; \\text{if } y = \\hat{y}\\end{cases} = \\textrm{Indicator}[y_i \\neq \\hat{y_i}]$, where $\\hat{y}$ is the predicted label\n  Training Set Error (rate)    Training set = $(x_1, y_1) \\cdot\\cdot\\cdot (x_n, y_n)$ \\begin{align*} \\frac{1}{n}∑ni=1L(x_i, y_i, \\hat{y_i}) = \\frac{1}{n}∑ni=1\\textrm{Indicator}[y_i ≠q \\hat{y_i}] \\end{align*}\n  Test Set Error    Test set = $(x_{n + 1}, y_{n + 1}) \\cdot\\cdot\\cdot (x_{n + m}, y_{n + m})$ \\begin{align*} \\frac{1}{n}∑n + mi=n+1\\textrm{Indicator}[y_i ≠q \\hat{y_i}] \\end{align*}\n  Why do we need a test set?    Machine learning assumes an underlying joint distribution \\begin{align*} p(x, y) \\text{ , unknown but fixed} \\end{align*} Training set is an independent and identically-distributed (i.i.d) sample from $p$. \\begin{align*} (x_i, y_i) \\textrm{} p(x, y) \\\\ (x_n, y_n) \\textrm{} p(x, y) \\end{align*} Test set is also an iid sample from $p$. Test set and Training set have the same underlying distribution. The future item that will be applied to the model also has the same underlying distribution.\n  True error    \\begin{align*} \\textrm{EXP}_{(x, y) \\textrm{~} p(x, y)} \\textrm{Indicator}[y_i ≠q \\hat{y_i}] \\text{ not computable} \\end{align*} Since we cannot compute this true error, we use test set to evaluate the model.\n  Accuracy    \\begin{align*} \\textrm{Accuracy} = 1 - \\textrm{error} \\end{align*}\n    How to choose k?  Method 1: Use a tuning set    randomly shuffle\n  split into training, tuning, and test set.\n  $\\hat{k} = \\textrm{argmin}_{k = 1, 2, ...}$ [tuning error with respect to kNN predictions (from training set)]\n  report $\\hat{k}NN$ prediction (from training set)\u0026#39;s test error.\n  If you use training error on kNN, then the training error is going to favor $k = 1$.\n  Method 2: Cross Validation    Start with full dataset, $(x_1, y_1) \\cdot\\cdot\\cdot (x_N, y_N) \\textrm{~} p$, split to two sets. The second set is test set\n  K-fold Cross Validation\n  Evenly split the first set into $k$ folds, $\\textrm{fold }1 \\cdot\\cdot\\cdot \\textrm{fold }k$\n  For $i = 1 \\cdot\\cdot\\cdot k$\t      use fold $i$ as the tuning set\n  and folds $1\\cdot\\cdot\\cdot k$ excepts $i$ as the training set\n  get tuning error $E_i$\n  Pick the model parameter ($k$ in $kNN$)\n    \\begin{align*} \\hat{k}kNN = \\textrm{argmin}_{kkNN}\\frac{1}{k_{\\textrm{fold}}}∑^{kfold}i = 1E_i \\end{align*}\n  In practice, $k \\in [5, 10]$\n  Retrain model on all folds as training set\n  Report test set error\n  Train $k+1$ times total\n        Logistic Regression  Recall    Supervised, Training Data $(x_i, y_i), i \\in [1, n]$\n  Regression, $y \\in R$\n      Linear Regression\n  $y = x^Tw + \\epsilon, y \\in R, x \\in R^(d+1), x = \\begin{bmatrix} 1\\\\.\\\\.\\\\.\\\\x_d\\end{bmatrix}, w = \\begin{bmatrix} w_0\\\\.\\\\.\\\\.\\\\w_d\\end{bmatrix}$\n  Classification, $y$ discrete finite \u0026#34;classes\u0026#34;\n      Naive Bayes\n  KNN\n  Logistic Regression\n    Logistic Regression    Input (Training data)    $(x_1, y_1) \\cdot\\cdot\\cdot (x_n, y_n)$ where \\begin{align*} \u0026amp;x_i = \\begin{bmatrix} 1\\\\x_{i1}\\\\.\\\\.\\\\.\\\\x_{id}\\end{bmatrix} ∈ Rd+1 \u0026amp;y_i ∈ \\{-1, 1\\} \\text{ binary classification or}, \u0026amp;y_i ∈ \\{1, 2, 3, ⋅⋅⋅, k\\} k\\text{-classes} \\end{align*}\n  Let\u0026#39;s start with binary classification\n  Binary Classification  Try to estimate conditional probability \\begin{align*} P_w(y=1|x) = \\frac{1}{1 + exp(-x^Tw)} \\text{ Sigmoid function} \\end{align*} if $x^T = 0, \\frac{1}{1 + e^{-0}} = \\frac{1}{1 + 1} = \\frac{1}{2}$ if $x^T = \\infty, \\frac{1}{1 + e^{-\\infty}} = \\frac{1}{1 + 0} = 1$ if $x^T = -\\infty, \\frac{1}{1 + e^{\\infty}} = \\frac{1}{1 + \\infty} = 0$ $x^Tw$ represents how strongly is the label going to be 1. \\begin{align*} P_w(y=1|x) = 1 - P_w(y=1, x) \\end{align*} For $y \\in \\{-1, 1\\}$, binary classification $P_w(y|x) = \\frac{1}{1+e^{-yx^Tw}}$\n  Training    Training   Estimate $s \\in R^{d+1}$ from training data (more later)\n  Prediction   Given a new item $x \\in R^{d+1}$, predict its label\n  \\begin{align*} \\hat{y} = \\textrm{argmax}_yP_w(y|x) \\end{align*}\n  K-class Logistic Regression  $y \\in {1, 2, 3, \\cdot\\cdot\\cdot, k}$ $w^{(1)} = \\begin{bmatrix} w^{(1)}_0\\\\.\\\\.\\\\.\\\\w^{(1)}_d\\end{bmatrix}$ $w^{(2)} = \\begin{bmatrix} w^{(2)}_0\\\\.\\\\.\\\\.\\\\w^{(2)}_d\\end{bmatrix}$ … $w^{(k-1)} = \\begin{bmatrix} w^{(k-1)}_0\\\\.\\\\.\\\\.\\\\w^{(k-1)}_d\\end{bmatrix}$ $w^{(k)} = \\begin{bmatrix} 0\\\\.\\\\.\\\\.\\\\0\\end{bmatrix}$ $P_w(y|x) = \\frac{e^{x^Tw^{(j)}}}{\\sum^{K}_{k=1}e^{x^Tw^{(k)}}}$, where $w$ is a collection of $w^{(1)}, \\cdot\\cdot\\cdot, w^{(k)}$\n  Example      1 The whole note is based on and is coming from the course materials of COMP SCI 540 by Professor Jerry Zhu and Hobbes LeGault.\n    ","permalink":"https://www.mrr1vfe.io/posts/cs540/","summary":"Basic Python, comparing to Java 1    Why are we using python?   It has a large amount of better machine learning libraries.\n  Useful link   Online Python compiler\n  Key differences from Java\t   Do not bother with a class unless you actually want to make an object.\n  Functions do not need return types (or parameter types).","title":"Introduction to Artifical Intelligence"},{"content":" Introduction 1  OS abstraction  Provide standard library to access resource that is valuable such as CPU, memory, and monitor. OS providing abstraction has a variety of advantages. It allows applications to reuse common facilities; it makes different devices look the same; and it provides higher-level or more useful functionality. The challenges of OS providing abstraction are identifying the correct abstraction and deciding how much of hardware should be exposed.\n  Resource management  Resource management means finding the best way that shares resources well. Sharing can be found in the case of multiple users of the system, multiple applications run by same user and multiple devices for same functionality. The reason why OS should provide resource management is that the resource management protects application at a common layer and also provides efficient and fair access to resources such as cost, time, and energy. Finding the correct mechanisms and policies of resource management is a challenge.\n  Goals of OS    Ease of use   Abstractions are easy to use.\n  Performance   getting best performance from one hardware\n  Isolation and Reliability   security\n    Three conceptual pieces of OS    Virtualization   Makes each application believe it has each resource to itself.\n  Concurrency   Events occur simultaneously and may interact with one another. Need to hide concurrency from independent processes and manage concurrency with interacting processes. Should provide abstractions like locks, semaphores, condition variables etc.\n  Persistence   Lifetime of data is longer than lifetime of any one process. Machine may lose power or crash unexpectedly. There are issues with the persistence. For example, high-level abstractions such as files, directories and links are needed to be implemented. Moreover, unexpected failure, such as power failure, program/OS crashes, needed to be handled correctly. Lastly, the performance can also be an issue since disks are very slow, comparing to CPU.\n      Project 3  Project 3: xv6 Memory sub-system Adding read only access to some pages in xv6, to protect the process from accidentally modifying it. The system, xv6, is not able to protect the memory. A process is able to alter its whole virtual memory, including code, while running. int mprotect(void *addr, int len)  It protest len number of pages starting at address addr by changing the protection bit to read-only. Trying to write to a read-only process will cause a trap, and the process will be killed.\n  addr   starting address of pages needing protection.   len   number of pages needing protection\n  return   return 0 when success, If addr is not page aligned or does not belong to current address space, or len ≤ 0, return 0 and does nothing.\n    int munprotect(void *addr, int len)  Reverse mprotect. This system call changes pages back to readable and writable.\n  fork() inheritance x  Process created by fork() should inherit pages it forked from, including the protection bit.\n  CR3 register and lcr()  Overwrote CR3 to let hardware know page-table entry has been changed.\n  Page allocation  In kalloc.c, kinit() shows how the free-list used by xv6 is initialized. When a page is needed, kinit() returns the first page in the free-list. It can also return NULL when not page can be allocated. Modifying this function kinit() allows different approaches of page allocation.\n  Alternate allocation   Keep a free frame between every allocated frame in the system.\n  Random allocation   Allocate the i-th frame, where i is a random number.\n    int dump_allocated(int *frames, int numframes)    frames   a pointer to an allocated array of integers.\n  numframes   size of frames\n  return   0 success, -1 error\n      Project 3 Discussion    allocuvm()   In kernel/vm.c. It allocates user virtual memory and return the new size.\n  mappages()   In kernel/vm.c. It creates PTE that maps virtual memory to physical memory.\n  walkpgdir()   In kernel/vm.c. Walking down the page table. Go to the appropriate page table directory and index into the inner page table entry.\n  mmu.h   Line 93 - 99 shows the page table layout. 32-bit address. 4KB pages, 2-level page table.\n  marco PDX(la)   la stands for logical address. Can extras page directory index given a logical address.\n    I/O Devices  System Architecture     Project 4a Discussion  Programming Model    Data Type   Each record is (key, value)\n  Map function   (Kin, Vin) → list(Kinter, Vinter)\n  Reduce function   (Kinter, list(Vinter)) → list(Kout, Vout)\n      1 The whole note is based on and is coming from the course materials of COMP SCI 537 by Professor Shivaram Venkataraman.\n    ","permalink":"https://www.mrr1vfe.io/posts/cs537/","summary":"Introduction 1  OS abstraction  Provide standard library to access resource that is valuable such as CPU, memory, and monitor. OS providing abstraction has a variety of advantages. It allows applications to reuse common facilities; it makes different devices look the same; and it provides higher-level or more useful functionality. The challenges of OS providing abstraction are identifying the correct abstraction and deciding how much of hardware should be exposed.","title":"Introduction to Operating Systems"},{"content":" Common Programming Concepts 1  Variables and Mutability    The default integer type for a positive number that is not so large is i32.\n  Variables by default are immutable.\n  Differences Between Variables and Constants    mut cannot be used with constants.\n  Declare constants with const keyword, and the type must be annotated.\n  Constant can only be set to constant expression, not value computed during runtime.\n    Shadowing    You can declare a new variable with the same name as a previous variable and the new variable shadows the previous variable.\n  Type can be changed when shadowing.\n  Type cannot be changed when re-assigning a value with a different type to a mutable variable\n      Data Types    Rust must know the types of all variables at compile time.\n  Scalar Types    scalar type   Type represents a single value.\n    Integer Types    Size of isize and usize depends on the architecture of which program runs on. 32 bits if running on a 32-bit architecture.\n  Integer literals support _ as a visual separator.\n  Default type is i32.\n    Floating-Point Types    There are f32 or f64 in Rust. There is no double.\n  Default type is f64.\n    Numeric Operations    Division behaves in the same way as C.\n    Boolean Type    Type bool has too possible values, true or false.\n    Character Type    Size of 4 bytes\n  Represents a Unicode Scalar Value.\n    Compound Types    compound types   Can group multiple values into one type.\n    Tuple Type    Create a tuple by writing a comma-separated list of values inside parentheses.\n  Each position in the parentheses has a type.\n  These types do not have to be the same.\n  fn main() { let tup: (i32, f32, i8) = (500, 6.4, 1); let (x, y, z) = tup; println!(\u0026#34;The value of y is {}\u0026#34;, y); }    One way to access a value inside a tuple is destructuring through pattern matching.\n  Another way to access a value is using . with an index. The first element in the tuple is indexed 0.\n  fn main() { let tup: (i32, f32, i8) = (500, 6.4, 1) println!(\u0026#34;The value of y is {}\u0026#34;, tup.1); }    Array Type    Each element in an array must has the same type.\n  Arrays in rust have fixed length.\n  Arrays are allocated on stack.\n  Type on an array is a composition of its elements\u0026#39; type and its length.\nlet a: [u8; 3] = [1, 2, 3];    An array can be initialized in the following way if each element has the same value.\nlet a = [4; 8]; // 8 elements, each element has a value of 4.     Accessing Array Element    Element can be accessed using indexing.\n  Rust will check if an index is in the bound in runtime.\n        Functions    fn allows you to declare a new function.\n  Functions can be defined anywhere in the source code.\n  Parameters of a function must have types declared.\n  Instructions that perform some action and do not return a value are statements.\n  Expressions Evaluate to a resulting value.\n  Expressions can be part of statements.\n  Function bodies are made up of a series of statements optionally ending in an expression.\n  Calling a function is an expression.\n  The block that we use to create new scopes, {}, is an expression.\n  Expressions do not include ending semicolons.\n  Functions with Return Values    Declare return value\u0026#39;s type using -\u0026gt;.\n  The return value of the function is synonymous with the value of the final expression in the block of the body of a function.\n  To return early, use return.\n      Control Flow    Unlike C, the condition must be a bool.\n  If    if is an expression, so it can be used on the right side of a let statement.\n  All arms must have the same type.\n    Repetition  Loop    The loop keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop by using the keyword break.\n  Value after the break expression will be return.\n    For    For each loop on collection\nlet numbers = [1, 2, 3, 4, 5]; for number in numbers.iter() { println!(\u0026#34;{}\u0026#34;, number); }    For each loop on range\nfor i in (1..4).rev() { println!(\u0026#34;{}\u0026#34;, i); }            Using Structs to Structure Related Data  Defining and Instantiating Structs    Using dot notation, ., to get a specific value from a struct.\n  A filed of an immutable struct cannot be modified.\n  If a struct is mutable, the dot notation can both access and modify fields of that struct.\n  Cannot make certain field of a struct mutable.\n  If variable that initialize a field has the same name as the field, no need to repeat the name.\nfn build_user(email: String, username: String) -\u0026gt; User { User { email, username, active: true, sign_in_count: 1, } }    When creating a new struct instance with some fields from an old instance, use .. specifies that the remaining fields have the same values as the fields in the given instance.\nlet user2 = User { email: String::from(\u0026#34;another@example.com\u0026#34;), username: String::from(\u0026#34;anotherusername567\u0026#34;), ..user1 };    Tuple struct does not provide names associated with its fields but types.\nstruct Color(i32, i32, i32); let black = Color(0, 0, 0);      Method Syntax    The first parameter for a method is always self.\n  Methods can also take ownership, like functions.\nstruct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } }    If a method inside impl block does not have self as its first parameter, then this method is considered as associated function.\n  Associated functions can be called by :: syntax.\n  Each struct can have multiple impl blocks.\n      Understanding Ownership  What is Ownership?    All data stored on the stack must have a known, fixed size.\n  Data with an unknown size at compile time or a size that might change must be stored on the heap instead.\n  Ownership Rules\n  Each value in Rust has a variable that\u0026#39;s called it s owner.\n  There can only be one owner at a time.\n  When the owner goes out of scope, the value will be dropped.\n    In Rust, the memory is automatically returned once the variable that owns it goes out of scope.\n  Rust calls drop automatically at the closing curly bracket where the variable will go out of scope.\n  Only copying those on the stack and pointers, which are also on the stack, to the heap, but not data on the heap.\n  This sounds like shallow copy, but rust invalid the variable being copied. That is, old variable cannot be read or wrote anymore.\n  This is known as move.\n  Copying everything on the heap is very expensive.\n  rust will never automatically create \u0026#34;deep\u0026#34; copies of your data.\n  Use common method clone to create a \u0026#34;deep\u0026#34; copy.\n  Ownership and Functions    The semantics for passing a value to a function are similar to those for assigning a value to a variable.\n  When a value passes into a function, the ownership also is passed into the function.\n  Returning a value can also pass ownership.\n      References and Borrowing    Reference allows you to refer to some value without taking ownership of it.\n  The \u0026amp;val syntax lets us create a reference that refers to the value val but does not own it.\n  We don\u0026#39;t drop what the reference points to when the reference goes out of scope because we don\u0026#39;t have ownership.\n  References are immutable by default.\n  You can have only one mutable reference to a particular piece of data in a particular scope.\n  We also cannot have a mutable reference while we have an immutable one.\n  The scope of a reference starts from where it is introduces and continues through the last time that reference is used.\n  The Rules of References:\n  At any given time, you can have either one mutable reference or any number of immutable references.\n  References must always be valid.\n        Enums and Pattern Matching  Defining an Enum    Enums can have different types.\n  Enums is similar to algebraic data types in functional programming languages.\n  Enums can have methods using impl.\nenum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32), HiTuple((i32, i32)), } impl Message { fn call(\u0026amp;self) { println!(\u0026#34;Hello Message\u0026#34;); } }    The Option Enum    Option\u0026lt;T\u0026gt; is provided by Rust, included in prelude.\nenum Option\u0026lt;T\u0026gt; { Some(T), None, }    Value of Option\u0026lt;T\u0026gt; typed cannot be used in place of value typed \u0026lt;T\u0026gt;.\n      The match Control Flow Operator    =\u0026gt; separates the pattern and the code to run.\n  You can use curly braces if there are multiple lines of code to run after pattern-matched.\n  We must exhaust every last possibility in order for the code to be valid.\n  _ will match any value\n    Concise Control flow with if let    if let matches one pattern.\nif let Some(3) = some_u8_value { println!(\u0026#34;three\u0026#34;); }    Compiler does not check if cases are exhaustive.\n  Can be used with a else statement.\n      Common Collections  Vector    Can only store values of the same type\n  When a vector gets dropped, all of its contents are also dropped.\n  Vectors are indexed by number, starting at zero.\n  Adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space.\n    String    The compiler can coerce the \u0026amp;String argument into a \u0026amp;str.\n  Using + to concatenate two strings s1 and s2, let s3 = s1 + \u0026amp;s2, actually takes ownership of s1, appends a copy of the contents of s2, and then returns ownership of the result.\n  Rust strings don\u0026#39;t support indexing.\n    Hash Map    The type HashMap\u0026lt;K, V\u0026gt; stores a mapping of keys of type K to values of type V.\n  We need to first use the HashMap form the collections portion of the standard library.\n  All of keys must have the same type, and all of the values must have the same type.\n  One can use collect method to turn a vector of tuples into a hash map.\n  Types that implement the Copy trait are copied into the hash map.\n  Owned values are moved and the hash map will be the owner of those values.\n  Inserting references to values into the hasp map does not move the value into the hash map.\n  get() returns an Option\u0026lt;\u0026amp;V\u0026gt;.\n  Insert a inserted key with different value will replace the old value.\n  Use entry() and or_insert() to insert a value if the key does not appear in the hash map.\n  or_insert() returns a reference to the value associates to the key.\n  Can dereference the return value of or_insert() to update the value.\n      Error Handling  Unrecoverable Errors with panic!    When the panic! macro executes, the program will print a failure message, unwind and clean up the stack, and then quit.\n  Set RUST_BACKTRACE=1 to display the backtrace.\n    Recoverable Errors with Result    Use unwrap() method on Result type. If the value is Ok variant, unwrap will return the value inside the Ok. If the Result is the Err variant, unwrap will call the panic! macro for us.\n  expect() is similar to unwrap(), but more detailed error message can be provided.\n  The ? operator can be used in Functions that return Result.\n      Traits, and Lifetimes  Traits: Defining Shared Behavior    A trait tells the Rust compiler about functionality a particular types has can share with other types.\n  When implementing a trait, put the trait name after impl and then use the for keyword and specify the name of the type we want to implement the trait for.\n  pub makes a trait public so that other crates are able to implement it.\n  We can implement a trait on a type only if either the trait or the type is local to our crate.\n  To use a default implementation, specify and empty impl block.\n  impl can also be used on type parameter.\n  + syntax to specify multiple trait bounds.\n  where clause allows clearer trait bounds.\n  impl Trait syntax can also be used in the return position, but this function should only return a single type.\n  Rust allows conditionally implement a trait.\n    Validating References with Lifetimes  Every reference in Rust has a lifetime.\n  Lifetimes prevent dangling references.\n  The names of lifetime parameters must start with an apostrophe (\u0026#39;).\n  We place lifetime parameter annotations after the \u0026amp; of a reference.\n  When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters.\n  Lifetimes syntax is about connecting the lifetimes of various parameters and return values of functions.\n  Lifetime Elision Rules\n  Each parameter that is a reference gets its own lifetime.\n  If there is exactly one input lifetime parameter, that lifetime is assigned to all.\n  If there are multiple input lifetime parameters, but one of them is \u0026amp;self or \u0026amp;mut self because this is a method, the lifetime of self is assigned to all output lifetime parameters.\n  -\u0026#39;static means that this reference can live for the entire duration of the program.\n      1 Notes from The Rust Programming Language\n    ","permalink":"https://www.mrr1vfe.io/posts/trpl/","summary":"Common Programming Concepts 1  Variables and Mutability    The default integer type for a positive number that is not so large is i32.\n  Variables by default are immutable.\n  Differences Between Variables and Constants    mut cannot be used with constants.\n  Declare constants with const keyword, and the type must be annotated.\n  Constant can only be set to constant expression, not value computed during runtime.","title":"Notes on The Rust Programming Language"},{"content":" Lecture 1 1  Functional programming  History    Based on $\\lambda$ calculus\n  Lisp\n  ML\n  Haskell\n    Building block    function   take inputs as arguments and produce outputs.\n  Functions are first class, like any other value. They can be passed to, returned by functions. Functions can also be combined into new function.\n  Control side-effects  Think about program is isolation\n  pure function   Described only by input and output. Always returns same result on fixed input.\n  Hidden state   avoid counters, local variables, etc.\n  Manage side-effects         A taste of Haskell  Declaring function  -- double is function\u0026#39;s name, :: indicates the type of this function. Int -\u0026gt; Int means it takes a Int as an input and outputs an Int double :: Int -\u0026gt; Int -- this line is optional, optional type signature / type annotation double n = n + n -- this is the function definition    Calling function  myBool = myFun 42 -- myFun is function name, 42 is the argument myBool = constFun () -- () called unit, not taking value    Multiple arguments  doubleTwos :: Int -\u0026gt; Int -\u0026gt; Int doubleTwos x y = double x + double y    Case analysis  doubleIfBig :: Int -\u0026gt; Int doubleIfBig n = if (n \u0026gt; 100) then n + n else n  or\ndoubleIfBig\u0026#39; n | n \u0026gt; 100 = n + n | otherwise = n    Case expression  listPrint :: [Int] -\u0026gt; String listPrint l = case l of [] -\u0026gt; \u0026#34;Empty\u0026#34; (x:xs) -\u0026gt; show x ++ \u0026#34; and \u0026#34; ++ show xs  or\nlistPrint :: [Int] -\u0026gt; String listPrint [] = \u0026#34;Empty list\u0026#34; listPrint (x:xs) = \u0026#34;...\u0026#34; -- x is the first element, xs is the rest of the list    Declare variables  tripleSecret :: Int tripleSecret = let secret = mySecretNum other = myOtherNum in 3 * secret + other  or\ntripleSecret = 3 * secret + other where secret = mySecret other = myOther    Tuples  Tuple can mix and match different types. An empty tuple is unit type.\nmyTuple :: (Int, Int) myTuple = (7, 42) myTriple :: (Int, Int, Int) myTriple = (7, 42, 108)    List  List takes same type, unlike tuple.\nmyList :: [Int]        Functional Programming 2  Compilation  Compile code\nghc --make [filename.hs]    Keywords    Do   The do keyword introduces a block of actions that can cause effects in the real world, such as reading or writing a file.\n  \u0026lt;-   Assignment operator inside the do block.\n    lines  The function, lines, are able to convert a string to a list of strings where each item in the list is a line in the given string. The \\n of a line will be discarded. However, when reading a file coming from Windows system, which prefers to put \\r\\n at the end of each line, using lines to split a string on an unix-based system would be a mess. The \\r will be remained in each item of the generated list. The following code are able to handle the \\r and \\r\\n cases.\nsplitLines :: String -\u0026gt; [String] splitLines [] = [] -- do nothing when facing an empty string splitLines cs = let (pre, suf) = break isLineTerminator cs -- pre contains substring before newline characters, suf contains everything else in pre : case suf of -- : operator is used to concatenate pre and modified suf (\u0026#39;\\r\u0026#39;:\u0026#39;\\n\u0026#39;:rest) -\u0026gt; splitLines rest -- rest is the remainder of the suf (\u0026#39;\\r\u0026#39;:rest) -\u0026gt; splitLines rest (\u0026#39;\\n\u0026#39;:rest) -\u0026gt; splitLines rest _ -\u0026gt; [] isLineTerminator c = c == \u0026#39;\\r\u0026#39; || c == \u0026#39;\\n\u0026#39;  When writing the code, organize the important part first. Give functions easy-to-understand name. Define less important function at the end is okay. The break provided by Prelude can break a list into two parts. break takes two arguments. The first one should be a function returns a boolean value, and the second one is a list. The function will examine each element of the list and decide if split at that element of not. If split, then return True, otherwise False. break is going to return a tuple of two lists. The first lists does not include the item which causes the function argument returning True.\nbreak (\\x-\u0026gt;x) [False, False, True, True] -- output: ([False,False],[True,True])    Infix    prefix   Writing the name of the function before its arguments.\n  infix   When a function has more than 1 arguments, it can be placed in between its first and second arguments.\n  a `times` b = a * b  infix notation does not change function\u0026#39;s behavior. It improves readability.\n  Data.List  prelude only exports a partial of functions in Data.List. In order to use all functions of Data.List in ghci, enter the following command\n:module +Data.List    length   return the number of elements in a list\n  null   determine whether a list is empty\n  head   access the first element of a list\n  tail   return a list of all but head\n  last   access the last element of a list\n  init   return a list of all but tail\n  Why not using length to check emptiness? List in Haskell does not contain its size. Therefore, length has to go through a whole list to find its size. In other words, length runs in liner time. A better alternative, null, not only runs in constant time but also clearly indicates the function of the code containing it.\n  partial functions   return values defined for a subset of valid inputs, like head\n  total functions   return valid results over their entire input domain\n  ++   append an list to another list\n  concat   concatenate a list of lists into a list; remove one level of nesting\n  reverse   reverse list order\n  and   and each element of a list of bool\n  or   or each element of a list of bool\n  all   takes a predicate, return True if the predicate succeeds on every element of a list\n  any   takes a predicate, return True if the predicate succeeds on at least one element of a list\n  Sublists    take   return a sublist of first $k$ elements\n  drop   return a sublist of without the first $k$ elements\n  split   split a list at index $k$; return a 2-tuple of list, item at index $k$ belongs to the second element of the tuple\n  takeWhile   take element from the beginning of the list as long as a predicate returns True\n  dropWhile   drop element from the beginning of the list as long as a predicate returns True\n  break   consume elements when predicate fails\n  span   consume elements when predicate is True\n    Searching List    elem   return true if an element is in a list\n  notElem   return true if an element is not in a list\n  filter   return all elements on which predicate succeeds\n  isPrefixOf   return true if a sublist appears in the front of a list\n  isInfixOf   return true if a sublist appears in a list\n  isSuffixOf   return true if a sublist appears in the end of a list\n    Multiple List    zip   combine two lists into a lists of pair, then length of the new list is the minimum length of the 2 given lists\n  zipWith   When zipping, apply a function\n    String handling    lines   partition a string into a list of substring based on \\n\n  unlines   concatenate a list of strings into a string. \\n is used to connect each element\n  words   partition a string into a list of substring based on space\n  unwords   concatenate a list of strings into a string. space is used to connect each element\n      Loops  There is not traditional loop in Haskell. Use recursion instead.\n  tail recursive function   function call itself at the end\n  Normally, a large amount of times of recursion will lead to stack overflow. However, functional programming languages implement TCO, or tail call optimization, to detect and transform tail recursion to constant space However, if need to apply function to each element of a list, map is a good function to use\n  high order function   function that takes another function as an argument\n  Fold    foldl   Fold from left of the list. Take a step function, an initial value for its accumulator, and a list.\n  step function   Take accumulator, an element from list, and return new accumulator; define how to update the accumulator in foldl\n  foldr   Fold from right of the list.\n  primitive recursive   class of functions that can be expressed using foldr\n  foldl could cause stack overflow due to the laziness of Haskell. Use foldl\u0026#39; from Data.List\n    Lambda Function    \\ [arguments] -\u0026gt; [function body / definition]\n  use a parentheses to let Haskell know where is the end of the function body\n  can only have one single clause in definition\n    Partial Function and Currying  In Haskell, all functions only take one argument.   partial function   the function formed by passing fewer arguments to an existing function\n  currying   application of partial function\n  section   enclose an operator in parentheses, supply its left or right argument inside the parentheses to get a partially applied function\n    As-pattern  xs@(_:xs\u0026#39;) is called an as-pattern, and it means “bind the variable xs to the value that matches the right side of the @ symbol. As-pattern allows sharing data. Thus a little bit better runtime than copying data.\n    Type Systems  Each program $e$ has a type $t$. Types describe what kind of program $e$ is, i.e. Boolean, Integer, etc. Some programs do not have a type but all programs have at most one type.\\\\\nBase types  The base types used in class are only \u0026#34;bool\u0026#34; for boolean and \u0026#34;int\u0026#34; for integer.\nbase-ty = \u0026#34;bool\u0026#34; | \u0026#34;int\u0026#34;    Function types  Type for lambda calculus. Denoted as ty -\u0026gt; ty. The first ty is the input type and the second ty is the output type. Note that both input and output can be functions.\nty = base-ty | ty -\u0026gt; ty    Full simple types examples  true has type bool 42 has type int plusOne = \\lambda x. x + 1 has type =int -\u0026gt; int\n  Typing context  Type depends on types of free variables in open terms. This kind of types are tracked in a typing context $G$\n  binding   $(x : t)$ means variable $x$ has type $t$\n  A typing context is a list of bindings. For example, A two-binding context $G$ is $G = x : bool, y : int$. Empty context is denoted as $G = \\cdot$.\n  Together  $G \\vdash e : t$ means program $e$ has type $t$ in context $G$.\n  Unicity of Typing   For every typing context $G$ and expression $e$, there exists at most one type $t$ such that $G \\vdash e : t$.\n  Inversion for Typing   Suppose that $G \\vdash e :t$. If $e = \\mathrm{add}(e_1, e_2)$, then $t = int, G \\vdash e_1 : int$, and $G \\vdash e_2 : int$.\n      Typeclasses 3  Define a Typeclass  class \u0026lt;Typeclass name\u0026gt; \u0026lt;instance types\u0026gt; where \u0026lt;function type prototype here\u0026gt;  Note that the keyword class here is different from the class in object-oriented languages.\n  instance type   type that implements the functions defined in the typeclass\n  For example:\nclass BasicEq a where -- the a is chosen arbitrary isEqual :: a -\u0026gt; a -\u0026gt; Bool -- defines one funciton  Interpret the type of a typeclass  The type of isEqual is\nisEqual :: BasicEq a =\u0026gt; a -\u0026gt; a -\u0026gt; Bool  =\u0026gt; is a type class constraint. The type of isEqual means if a is an instance of BasicEq, then isEqual takes two a as parameters and return a Bool.\n    Define an instance  instance \u0026lt;Typeclass name\u0026gt; \u0026lt;instance type\u0026gt; where \u0026lt;functions here\u0026gt;  For example\ninstance BasicEq Bool where isEqual True True = True isEqual False False = True isEqual _ _ = True  Now, isEqual works for Bool, but not for any other types since there is no instance created for other types. The compiler does not know how to compare types other than Bool\n    Review I  Haskell  Function    Multiple arguments, Anonymous Functions (\\x -\u0026gt; x + 1)\n    Recursions  f :: [a] -\u0026gt; Int -\u0026gt; [a] f list times = concat $ map dup list where dup 0 x = [] dup times x = x : dup (times - 1) x    Higher older function  .  (a -\u0026gt; b) -\u0026gt; (b -\u0026gt; c) -\u0026gt; (a -\u0026gt; c) function composition\n  $  function application\n  map\n  foldr\n  zip\n      Curry  ((a, b) -\u0026gt; c) -\u0026gt; a -\u0026gt; b -\u0026gt; c\n  Types  (newtype, data (most powerful), type (least powerful))\n  type has to use with existed type\ntype Dollar = Int    newtype only has one field\nnewtype AppendList a = AList ([a] -\u0026gt; [a])    data could be anything. Like a tree, node, etc.\ndata Tree = Leaf a | Node Left Mid Right | Child [a] | Empty      Typeclasses / subclasses  Functors  Functor m pure :: a -\u0026gt; m a pure a = Just a fmap (a -\u0026gt; b) -\u0026gt; m a -\u0026gt; m b -- \u0026lt;$\u0026gt; is fmap fmap f m = case m of Nothing -\u0026gt; Nothing Just val -\u0026gt; Just $ f val    Applicative\n    Monads\n  IO Monads\n          Theory    Syntax\n  digit = 0 | 1 | 2 | 3 … exp = num + exp | exp\n    Lambdas Calculus (Not-typed)\n  Semantics (small-step)\n  Type theory (add safety = progress(can step) + preservation(step to same type))\n  Bigger Types (P × Q, P + Q)\n      Rust Language  [[./TRPL.html][Notes on The Rust Programming Language]\n  References and Borrowing    References is an indirect name for some data. Similar to a pointer to some data.\n  Reference does not own the data.\n  Can have only one owner, but many references.\n    Reference going out of scope does not drop data.\n  Can \u0026#34;borrow\u0026#34; reference to function\n    Function can take (mutable) reference and modify caller\u0026#39;s data directly\n  Useful for mutable datastructures.\n    Reference themselves are on stack.\n  By default, references are immutable.\n  Can\u0026#39;t change underlying data through references.\n  Reference type: \u0026amp;T\n    Can declare mutable references\n  Target must be mutable as well\n  Reference type: \u0026amp;mut T\n  let must my_str = String::from(\u0026#34;foo\u0026#34;); // mutable var let ref_to_str = \u0026amp;mut my_str; // mutable ref to my_str     Dereferencing    Use * notation to get thing reference is pointing at\n  Often not needed due to \u0026#34;auto-deref\u0026#34; (magic)\nlet vr: \u0026amp;Vec\u0026lt;i32\u0026gt; = ...; println!(\u0026#34;First element: {}\u0026#34;, (*vr)[0]); // Explicit deref println!(\u0026#34;First element: {}\u0026#34;, vr[0]); // Implicit deref println!(\u0026#34;First element: {}\u0026#34;, vr.first); // Implicit deref       Somewhat confusingly  Reference itself can be mutable\n// Can\u0026#39;t change ref or thing it\u0026#39;s pointing at let immut_ref_to_immut = \u0026amp;my_string; // Can\u0026#39;t change ref, can change thing it\u0026#39;s pointing at let immut_ref_to_mut = \u0026amp;mut my_string; // Can change ref, can\u0026#39;t change thing it\u0026#39;s pointing at let mut mut_ref_to_immut = \u0026amp;my_string; mut_ref_to_immut = \u0026amp;my_other_string; // Can change ref and thing it\u0026#39;s poing at let mut mut_ref_to_mut = \u0026amp;mut my_string; mut_ref_to_mut = \u0026amp;mut my_other_string; *mut_ref_to_mut = String::from(\u0026#34;???\u0026#34;);    What\u0026#39;s going one    Mutability is not a property of the data!\n  Not: these bits are mutable or immutable\n    Mutability is property of variable or reference\n  YES: I can mutate data through this variable\n  YES: I cannot mutate data through that reference\n      Multiple References    Rust works hard to ensure one owner for each data\n  Multiple references to same data is problematic\n  Also known as aliasing\n    References need to follow certain rules for safty\n  In any scope, there can be either:\n  Any number of immutable references referring to the same variable\n  At most one mutable reference referring to the same variable\n      Multiple Immutable    Can have any number of immutable references to variable\n  Safe: none of the references can change the underlying\nlet my_str = String::from(\u0026#34;foo\u0026#34;); let ref_one = \u0026amp;my_str; let ref_two = \u0026amp;my_str; println!(\u0026#34;Both refs: {} {}\u0026#34;, ref_one, ref_two); // OK       At Most One Mutable    Can only change underlying through single reference\n  Also important in concurrent setting\n  Also enables more optimizations\n  let mut mut_str = String::from(\u0026#34;foo\u0026#34;); let ref_one = \u0026amp;mut mut_str; // OK let ref_two = \u0026amp;mut mut_str; // Not OK       Use Scopes to Manage References  Rules only apply to references currently in scope.\nlet mut mut_str = String::from(\u0026#34;foo\u0026#34;); let mut_ref = \u0026amp;mut mut_str; mut_ref.push(\u0026#34;bar\u0026#34;); // OK mut_str.push(\u0026#34;baz\u0026#34;); // Not OK  // Use scopes! let mut mut_str = String::from(\u0026#34;foo\u0026#34;); { let mut_ref = \u0026amp;mut mut_str; mut_ref.push(\u0026#34;bar\u0026#34;); // OK } mut_str.push(\u0026#34;baz\u0026#34;); // OK     Alternative Reading    Immutable reference shared reference\n  Shared access to some data\n  Sharing: can\u0026#39;t change the data\n    Mutable reference: unique reference\n  Exclusive access to some data\n  Can modify it: no one else has access\n    Can\u0026#39;t mix shared and unique!\n    Isn\u0026#39;t a Reference Just a Pointer?    In machine code: a reference is just a pointer\n  In Rust: a reference also gives permissions to do things\n  With an immutable reference, code can\n  Dereference/read location\n  Point to/read anything reachable from reference.\n    With an mutable reference, code can\n  Dereference/read/write location\n  Point to/read/write anything reachable from reference.\n      Passing Arguments  \u0026#34;Moving\u0026#34; Arguments    Operationally: arguments passed \u0026#34;by value\u0026#34;\n  Ownership of argument passes into the function\n  Caller can\u0026#39;t use arguments after calling!\n  Arguments moved into function\n    Function can return argument to return ownership\n    \u0026#34;Borrowing\u0026#34; Arguments    Operationally: arguments passed \u0026#34;by reference\u0026#34;\n  Ownership of argument doesn\u0026#39;t change\n  Original owner (caller, caller-of-caller, …) owns argument.\n    Function borrows arguments from the owner\n  Will give it back to owner when done with it\n        Variables Are Key    Anywhere there are variables:\n  Think about ownership rules\n  Think about borrowing rules\n      Matching Can Move Data    Often: matching on Enums with data inside\n  The inner data is moved into the match arm\n  Variable from match arm has ownership\n    Typical ownership rules apply\n  Data is dropped at the end of the arm\n      Matching on a reference    Rust will infer how to borrow inner values\n  Matching on \u0026amp;T type: arms borrow immutable\n  Marching on \u0026amp;must T type: arms borrow mutable\n    Also called \u0026#34;default binding modes\u0026#34;\n  Usually: Just work\n  Sometimes; inferences goes wrong (doesn\u0026#39;t work)\n        1 The whole note is based on and is coming from the course materials of COMP SCI 538 by Professor Justin Hsu.\n  2 Notes from Real World Haskell by Bryan O\u0026#39;Sullivan, Don Stewart, and John Goerze\n  3 Notes from Real World Haskell by Bryan O\u0026#39;Sullivan, Don Stewart, and John Goerze\n  Typeclasses   Typeclasses define a set of functions that can have different implementations depending on the type of data they are given.\n      ","permalink":"https://www.mrr1vfe.io/posts/cs538/","summary":"Lecture 1 1  Functional programming  History    Based on $\\lambda$ calculus\n  Lisp\n  ML\n  Haskell\n    Building block    function   take inputs as arguments and produce outputs.\n  Functions are first class, like any other value. They can be passed to, returned by functions. Functions can also be combined into new function.","title":"Theory and Design of Programming Languages"},{"content":" Locality  Principle of locality  Programs tend to use data and instructions with addresses near or equal to those they have recently used.\n  temporal locality   Recently referenced items are likely to be referenced again in the near future.\n  spatial locality   Items with nearby addresses tend to be referenced close together in time.\n    Locality Example  sum = 0; for (int i = 0; i \u0026lt; n; i++) sum += a[i]; return sum;  Data References    Reference array elements in succession (stride - 1 reference pattern). spatial locality\n  Reference variable =sum= each iteration. temporal locality\n    Instructions References    Reference instructions in sequence. spatial locality\n  Cycle through loop repeatedly. temporal locality\n        Cache    cache   A smaller, faster storage device that acts as a staging area for a subset of the data in a larger, slower device.\n  Fundamental idea of a memory hierarchy  For each k, the faster, smaller device at level k servers as a cache for the larger, slower device at level k + 1.\n  Why do memory hierarchies work?    Because of locality, programs tend to access the data at level k more often than they access the data at level k + 1.\n  Thus, the storage at level k + 1 can be slower, and thus larger and cheaper per bit.\n    Big Idea  The memory hierarchy creates a large pool of storage that costs as much as the cheap storage near the bottom, but that serves data to programs at the rate of fast storage near the top.\n  Hit  Block looking for is in cache\n  Miss  Block looking for is not in cache\nCold miss  Cold misses occur because the cache is empty.\n  Conflict miss    Most caches limit blocks at level k + 1 to a small subset (sometimes a singleton) of the block positions at level k. e.g. Block i at level k + 1 must be placed in block (i mod 4) at level k.\n  Conflict misses occur when the level k cache is large enough, but multiple data objects all map to the same level k block. e.g. Referencing blocks 0, 8, 0, 8, 0, 8, … would miss every time.\n    Capacity miss  Occurs when the set of active blocks (working set) is larger than the cache.\n  Placement policy  determines where block goes\n  Replacement policy  determines which block gets evicted\n  General Cache Organization (S, E, B)    S = 2^s sets\n  E = 2^e lines per set\n  B = 2^b bytes per cache block\n  C = S × E × B is the Cache size\n  Address of word    lower bits, b-bits are block offset\n  s-bits are index of set\n  remaining t-bits are tag\n  The cache take this address, and first extract the s-bits, and use it as an index to identify the set. If the block that contains this data word is in the cache, it is going to be in the set that is denoted by the set index. And then it checks the tag, check all lines in the set to see if any lines of the set has a matching tag, and check if the valid bit is turned on.\n  locate set\n  check if any line in set has matching tag\n  Yes + line valid, hit\n  locate data starting at offset\n    if the tag does not match, old line is evicted and replaced.\n        Direct Mapped Cache  E = 1, one line per set\n  E-way Set Associative Cache  E = 2, two lines per set\n  search for matching tag in the same set at the same time\n  once identify the match, locate data starting at offset\n      Writing  What to do on a write-hit?    write through   write immediately to memory, always mirror the content of lower memory.\n  write back   defer write to memory until replacement of line. Need a dirty bit to determine if line different from memory or not.\n    What to do on a write-miss?    write-allocate   load into cache, update line in cache. Good if more writes to the location follow.\n  No-write-allocate   writes straightly to the memory, does not load into cache.\n    Typical combination    write through + no-write-allocate\n  write back + write-allocate\n      Cache performance Metrics  Miss Rate    fraction of memory references not found in the cache (misses / accesses) = 1 - hit rate.\n  typical numbers in percentages\n  3 - 10% for L1 cache\n  can be quite small (e.g. \u0026lt; 1%) for L2, depending on size, etc.\n      Hit Time    time to deliver a line in the cache to the processor\n  includes time to determine whether the line is in the cache\n    typical numbers\n  4 clock cycles for L1\n  10 clock cycles for L2\n      Miss Penalty    Additional time required because of a miss\n  typically 50 - 200 cycles for main memory\n        ","permalink":"https://www.mrr1vfe.io/posts/memory-and-cache-review/","summary":"Locality  Principle of locality  Programs tend to use data and instructions with addresses near or equal to those they have recently used.\n  temporal locality   Recently referenced items are likely to be referenced again in the near future.\n  spatial locality   Items with nearby addresses tend to be referenced close together in time.\n    Locality Example  sum = 0; for (int i = 0; i \u0026lt; n; i++) sum += a[i]; return sum;  Data References    Reference array elements in succession (stride - 1 reference pattern).","title":"Memory and Cache Review"},{"content":" 环境搭建与入门案例  环境搭建  pip3 install django==2.2 pip3 install pymysql pip3 install mysqlclient pip3 install pillow    主文件夹中的文件    settings.py   总配置文件\n  urls.py   总路由映射文件, 把请求过来的url地址进行分配，分配给不同的handler处理器，处理器处理得到不同的结果，并把结果返回给浏览器\n  wsgi.py   项目部署\n    项目搭建步骤    创建Django项目\n  创建app并在settings中配置\n  创建urls.py并在总路由中配置\n  定义首页视图\n  定义解析器\n  运行manage.py\n    创建app并在settings中配置  django-admin startapp myapp    通过settings.py引入创建的app\n  INSTALLED_APPS = [ \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;myapp\u0026#39;, # 新创建的app名称 ]    创建urls.py并在总路由中配置    在myapp文件夹中创建一个python文件, urls.py   在总路由urls.py中添加\n  from django.urls import path, include urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;\u0026#39;, include(\u0026#34;myapp.urls\u0026#34;)) ]    定义首页视图  在myapp/urls.py中添加\nfrom django.urls import path from . import views urlpatterns = [ path(\u0026#39;\u0026#39;, views.index_handler) ]    定义解析器  使用快捷键 option + enter 可以在views.py中快速创建解析器, 将views.py中的代码修改为\nfrom django.shortcuts import render, HttpResponse def index_handler(request): return HttpResponse(\u0026#39;Hello Django\u0026#39;)    运行manage.py  python3 manage.py runserver 8000      基本路由映射    总路由文件\nurlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;user/\u0026#39;, include(\u0026#34;myapp.urls\u0026#34;)) ]    myapp中的urls.py\nurlpatterns = [ path(\u0026#39;name1\u0026#39;, views.index_handler) ]    可通过[host地址/user/name1] 访问 views.index_ handler，并拿到index_ handler返回的数据\n  命名空间  在总路由文件中的urlpatterns添加\npath(\u0026#39;user/\u0026#39;, include((\u0026#39;myapp.urls\u0026#39;, \u0026#39;myapp\u0026#39;), namespace=\u0026#39;user\u0026#39;))    正则参数传递与接收    导入re_ path\nfrom django.urls import re_path    re_ path的使用\nurlpatterns = [ re_path(\u0026#39;(\\d+)\u0026#39;, views.re_handler) ]    处理器接收\ndef re_handler(request, num): return HttpResponse(num) # num对应正则表达式传递过来的参数      基础正则表达式  . 除了\\n和\\r所有的字符  \\d 数字  \\D 非数字  \\w 字母和下划线  \\W 非字母和下划线  \\s 空格，包括制表符，换页符  *出现次数 \u0026gt;= 0  +出现次数 \u0026gt;= 1  {n} 出现次数 = n  {n, m} m \u0026gt;= 出现次数 \u0026gt;= n  ^ 以开头  $ 以结尾    反向解析处理器    导入\n  from django.shortcuts import reverse    无参处理器解析\n  reverse(\u0026#39;[命名]\u0026#39;)    有参处理器解析\n  reverse(\u0026#39;[命名]\u0026#39;, args=([参数1], [参数2], ...))    request和response  客户端向服务器request数据，服务器response数据给客户端\nrequest对象HttpRequest     关键字 说明     method 返回请求的方式 (GET/POST)   path 返回页面的路径 (不包括域名)   META 封装请求头的数据 (字典类型，key大写，下划线连接)   GET 封装GET请求数据的QueryDict对象   POST 封装POST请求数据的QueryDict对象   FILES 封装上传文件数据   COOKIES 封装请求的cookies，类似字典的对象   session 可读写的类似字典的对象      GET请求会讲数据放在url中\n  POST请求会把数据封装在header里面，并加密\n  POST更安全，对于表单提交和敏感数据，通常使用POST请求\n  META的CONTENT_ TYPE请求正文的MIME类型\n  text/html HTML\n  text/plain 普通文本\n  application/json Json\n    Python字典和Json的区别\n  Python使用None表示空，Json使用Null\n  Json中的true和false首字母小写\n    COOKIES保存在客户端，例如自动登陆功能\n  session保存在服务端，保存敏感信息，根据COOKIES上传的值获取\n    response对象HttpResponse  HttpResponse( content=\u0026#34;[相应体]\u0026#34;, content_type=\u0026#34;[MIME类型]\u0026#34;, status=\u0026#34;[状态码]\u0026#34; )     状态码 解释     200 请求成功   400 客户端请求语法错误   403 服务器拒绝请求   404 没有找到对应页面   500 服务器内部错误      JsonResponse对象  from django.http import JsonResponse JsonResponse( { \u0026#34;edu\u0026#34;: \u0026#34;education\u0026#34;, \u0026#34;course\u0026#34;: \u0026#34;Python语言\u0026#34; }, json_dumps_params={\u0026#34;ensure_ascii\u0026#34;: False} # 保证中文正确显示 )    重定向  from django.shortcuts import redirect def redirect_handler(request): return redirect(\u0026#39;/user\u0026#39;) # 重定向到用户首页 # 通过reverse配合重定项 from django.shortcuts import reverse def rredirect_handler(request): return redirect(reverse(\u0026#34;user:index\u0026#34;)) # 重定向到用户首页      前端  标签语言    双标签\n\u0026lt;标签名\u0026gt;\u0026lt;/标签名\u0026gt;    单标签\n\u0026lt;标签名/\u0026gt;      元素与属性  \u0026lt;标签名 属性名=属性值\u0026gt;元素\u0026lt;/标签名\u0026gt; \u0026lt;标签名 属性名=属性值/\u0026gt;    其他资源  Stanford HTML Cheatsheet\n  HTML   名词\n  CSS   形容词\n  javascript   动词\n      模板原理  模板调用    在templates文件夹中创建html文件，例如index.html\n  在视图中调用\ndef index_handler(request): return render(request, \u0026#39;index.html\u0026#39;)      模板传参  def index_handler(request): context = { \u0026#39;username\u0026#39;: \u0026#39;name1\u0026#39;, \u0026#39;password\u0026#39;: \u0026#39;pass1\u0026#39; } return render(request, \u0026#39;index.html\u0026#39;, context)    模板层基础语法  参数输出    普通值\n{{ key1 }}    列表值\n{{ key2.0 }} {{ key2.1 }}    字典值\n{{ key3.key3_1 }} {{ key3.key3_2 }}    变量名不可以以下划线开头, {#…#}是模版层中的注释\n  循环语句  context = { \u0026#39;loves\u0026#39;: [\u0026#39;python\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;java\u0026#39;] }  {% for love in loves %} {% endfor %}    判断语句  {% if 条件%} {% elif 条件%} {% else 条件%} {% endif 条件%}    视图函数地址    不需要额外传参的视图函数\n  {% url \u0026#34;[namespace]:[name]\u0026#34; %}    需要传参的视图函数，例如\ndef re_handler(request, num):  {% url \u0026#34;[namespace]:[name]\u0026#34; [传递的参数] %}        模板过滤器    过滤器   模板中对传递过来的数据进行修饰，再进行显示\n  ?   过滤器语法\n{{ 变量|过滤器关键字: 参数 }}  如果没有参数传递，可以不写\n  常用过滤器     关键字 说明     safe 禁止HTML转义   length 长度   date 日期 (Y-m-d H:i:s)   default 默认值   upper 转大写   lower 转小写        模板复用和block提取    模板继承\n{% extends \u0026#34;[父模板路径]\u0026#34; %}    block块定义与重写\n{% block [代码块名称] %} {% endblock %}  调用父模板中的代码\n{{ block.super }}        MySQL数据库基础  数据库的创建与删除     操作 命令     创建数据库 create database [数据库名];   删除数据库 drop database [数据库名];      使用与查看数据库     操作 命令     使用数据库 use [数据库名];   查看所有的数据库 show databases;   查看当前使用的数据库 select database();      数据库编码     操作 命令     创建数据库并指定编码 (utf-8) create database [数据库名] charset=\u0026#34;utf8\u0026#34;;   修改数据库编码（gbk） alter database [数据库名] charset=\u0026#34;gbk\u0026#34;;      常用数据类型    整数\n   关键字 含义     tinyint -2^7 ~ 2^7 - 1   smallint -2^16 ~ 2^16 - 1   mediumint -2^23 ~ 2^23 - 1   int -2^31 ~ 2^31 - 1   bigint -2^63 ~ 2^63 - 1      定点数\n   关键字 含义     decimal(m, d) 总位数 \u0026lt; m, 小数位 = d      浮点数\n   关键字 含义     float(m, d) 16位精度，总位数 \u0026lt; m, 小数位 = d   double(m, d) 16位精度，总位数 \u0026lt; m, 小数位 = d    浮点数只能保证最多8或16位的准确性，其余的数字随机填充\n  字符串\n   关键字 含义     char(n) 固定字符串长度n   varchar(n) 最大字符串长度n      日期\n   关键字 含义     datetime YYYY-MM-DD HH:MM:SS   date YYYY-MM-DD   time HH:MM:SS      布尔\n   关键字 含义     boolean true/false    底层其实是tinyint\n    创建表结构  create table [表名] ( [字段名] [字段类型] [字段约束], [字段名] [字段类型] [字段约束] );    常用字段约束     约束类型 关键字     主键自增 primary key auto_increment   不能重复 unique   不能为空 not null   默认值 default      查询操作    查看表内所有数据\nselect * from [表名];  *表示为所有字段\n  查看指定字段 select [字段1], [字段2] from [表名];    比较条件查询\nselect * from [表名] where [条件];     条件 命令     相等 =   不相等 !=   为空 is null   不为空 is not null   大于 \u0026gt;   小于 \u0026lt;      模糊查询\nselect * from [表名] where [字段] like \u0026#34;表达式\u0026#34;;     关键字 说明     % 匹配任意多的字符   _ 匹配一个字符，汉字需要使用两个      范围查询\nselect * from [表名] where [字段] in ([可能1], [可能2], ...);    逻辑运算符\n   关键字 说明     and 与   or 或      分组\nselect * from [表名] where [条件] group by [字段1], [字段2], ...;    按照哪个字段分组，哪个字段就不会重复\n  group by要写在where的后面\n  select * from [表名] where [条件] group by [字段1], [字段2], ... having [条件];    where是对select…的结果进行筛选\n  having是对group by的结果进行筛选\n    排序\nselect * from [表名] where [条件] group by [字段1], [字段2], ... having [条件] order by [字段1] asc/desc, [字段2] asc/desc;    asc   升序\n  desc   降序\n  排序优先级   先按照 [字段1] 排序， 如果相同，那么按照 [字段2] 排序\n    分页\nselect * from [表名] where [条件] group by [字段1], [字段2], ... having [条件] order by [字段1] asc/desc, [字段2] asc/desc limit [起始索引], [数据条数];      增删改查    插入数据\ninsert into [表名] value ([数据1], [数据2], ...);  insert into [表名] ([字段名1], [字段名2], ...) value ([数据1], [数据2], ...);  insert into [表名] ([字段名1], [字段名2], ...) values ([数据1], [数据2], ...), ([数据3], [数据4], ...);    修改数据\nupdate [表名] set [字段1] = [值1], [字段2] = [值2] ... where = [条件];    删除数据\ndelete from [表名] where [条件];      插入数据   多条数据插入尽量用一条sql语句，提高性能      关键字 说明     delete 删除表内行数据   drop table 删除整个表，可以恢复   truncate 删除整个表，快速，但不可恢复      多表操作    一对多\ncreate table user ( id int primary key auto_increment, username varchar(16) );  create table forum( id int primary key auto_increment, topic varchar(200), user_id int, constraint fu1 foreign key (user_id) references user(id) on delete CASCADE );     级联类型 解释     on delete restrict 默认值，抛异常   on delete cascade 如果主表被引用的外键删除，相关 联的表的记录也会被删除   on delete set null 如果主表被引用的外键删除，相关 联的表的外键设置为空   on delete no action 什么也不做      多对多\ncreate table user_forum( id int primary key auto_increment, user_id int, forum_id int, constraint c1 foreign key (user_id) references user(id) on delete cascade, constraint c2 foreign key (forum_id) references forum(id) on delete cascade );    一对一 不常用，应用场景:\n  单张表内字段数太多   敏感信息分离\n      ORM    配置 Settings中:\nDATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39; : \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;localhost\u0026#39;, \u0026#39;PORT\u0026#39;: \u0026#39;3306\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;【数据库名称】\u0026#39;, \u0026#39;USER\u0026#39;: \u0026#39;【MySQL账号】\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;【密码】\u0026#39; } }    表与字段定义 models.py中:\nclass User(models.Model): id = models.AutoField(primary_key=True) username = models.CharField(max_length=16) password = models.CharField(max_length=16) gender = models.PositiveSmallIntegerField() age = models.IntegerField() createDatetime = models.DateTimeField()  字段名不要用 __ 开头\n   字段类型关键字 说明     AutoField 自动增长的整数(相当于:int auto_increment)   IntegerField 整数 int   FloatField 浮点数   Decimal 定点数   CharField 字符串 varchar()   TextField 大文本 Text   BooleanField True/False   DateTimeField 日期 Datetime: YYYY-MM-DD HH:MM:SS   EmailFiled 邮箱   ImageField 图片   primary_key 是否是主键   null 能否为空   unique 能否重复   default 默认值   blank 在django管理后台新增或编辑一条表数据 时，该字段能否为空 null是数据库范畴，blank是表单验证范畴      数据库迁移与维护\n  生成迁移文件\n    python manage.py makemigration    执行迁移文件\n  python manage.py migrate    增删改查\nuser = User() user.username = \u0026#39;name1\u0026#39; user.id user.save() user.password = \u0026#39;pass1\u0026#39; user.save() user.delete() user = User.objects.create( username = \u0026#34;name2\u0026#34; ) # 修改 User.objects.filter(【条件】).update(属性=属性值) # 例如 User.objects.filter(id=2).update(password=\u0026#34;pass2\u0026#34;) # 删除 User.objects.filter(id=2).delete()      模型类的查询方法     方法 说明     all() 返回所有   get(条件) 返回满足条件的数据   filter(条件) 返回满足条件的数据   exclude(条件) 返回不满足条件的数据    get方法必须返回一个对象 如果没有满足条件的对象，或者有多个满足条件的对象，都会报异常 all、filter、exclude返回的结果类型是QuerySet(类似列表)\nusers = User.objects.all() users = User.objects.filter(id=1) users = User.objects.exclude(id=1)  比较查询     条件 说明     相等 exact   大于 gt   大于等于 gte   小于 lt   小于等于 lte   为空查询 isnull      条件格式   【字段名】__【条件关键字】=【比较值】\n  # 查询id\u0026gt;=2的所有用户 users = User.objects.filter(id__gte=2)    模糊查询     条件 说明     包含 contains   开头 startswith   结尾 endswith    # 查询用户名中包含\u0026#39;1\u0026#39;的用户 user1_s = User.objects.filter(username__contains=\u0026#39;1\u0026#39;) # 查询用户名以\u0026#39;name1\u0026#39;开头的用户 user2_s = User.objects.filter(username__startswith=\u0026#39;name1\u0026#39;) # 查询邮箱以\u0026#39;@qq.com\u0026#39;结尾的用户 user3_s = User.objects.filter(email__endswith=\u0026#39;@qq.com\u0026#39;)    范围查询     条件 说明     范围 in    # 查询username属于[\u0026#34;name1\u0026#34;，\u0026#34;name2\u0026#34;]的user对象 users = User.objects.filter(username__in= [\u0026#34;name1\u0026#34;，\u0026#34;name2\u0026#34;]        Redis  安装包  pip3 install redis pip3 install django-redis pip3 install django-redis-sessions    settings配置  SESSION_ENGINE = \u0026#39;redis_sessions.session\u0026#39; SESSION_REDIS_HOST = \u0026#39;localhost\u0026#39; SESSION_REDIS_PORT = 6379 SESSION_REDIS_DB = 0 SESSION_REDIS_PASSWORD = \u0026#39;\u0026#39;      CSRF跨域  添加CSRF_TOKEN  在form表单中添加\n{% csrf_token %}      ","permalink":"https://www.mrr1vfe.io/posts/django_note/","summary":"环境搭建与入门案例  环境搭建  pip3 install django==2.2 pip3 install pymysql pip3 install mysqlclient pip3 install pillow    主文件夹中的文件    settings.py   总配置文件\n  urls.py   总路由映射文件, 把请求过来的url地址进行分配，分配给不同的handler处理器，处理器处理得到不同的结果，并把结果返回给浏览器\n  wsgi.py   项目部署\n    项目搭建步骤    创建Django项目\n  创建app并在settings中配置\n  创建urls.py并在总路由中配置\n  定义首页视图\n  定义解析器\n  运行manage.py\n    创建app并在settings中配置  django-admin startapp myapp    通过settings.","title":"Python后台开发"}]