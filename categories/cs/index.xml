<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CS on mrr1vfe</title>
    <link>https://www.mrr1vfe.io/categories/cs/</link>
    <description>Recent content in CS on mrr1vfe</description>
    <image>
      <url>https://www.mrr1vfe.io/papermod-cover.png</url>
      <link>https://www.mrr1vfe.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 24 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.mrr1vfe.io/categories/cs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Decimal Numbers</title>
      <link>https://www.mrr1vfe.io/posts/decimal-numbers/</link>
      <pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/decimal-numbers/</guid>
      <description>Notes on Rust in Action, by Tim McNamara
Scientific Notation \[3.14 \times 10 ^ 8 \]
 ::Sign:: representing positive or negative ::Mantissa:: 3.14 ::Radix:: 10 ::Exponent:: 8  Floating Point Computers use scientific notation in memory to represent floating point numbers. A floating number in memory is constitutive of 3 parts
 ::Sign:: ::Mantissa:: ::Exponent:: The ::radix:: is predefined to be 2 and therefore does not need to be stored.</description>
    </item>
    
    <item>
      <title>Global variables</title>
      <link>https://www.mrr1vfe.io/posts/global-variables/</link>
      <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/global-variables/</guid>
      <description>Notes on Rust in Action, by Tim McNamara
 All caps If mutable, it’s modifier is static mut, meaning the variable has a mutable static lifetime (valid for the life of the program). If immutable, use const instead.  Code that modify global variable should be placed into an unsafe block. unsafe means as safe as C.
const vs. let Although let also defines immutable variable, it defines run time constant.</description>
    </item>
    
    <item>
      <title>Struct, Enum</title>
      <link>https://www.mrr1vfe.io/posts/struct-enum/</link>
      <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/struct-enum/</guid>
      <description>Notes on Rust in Action, by Tim McNamara
type Just an aliasing mechanism. For example, the following code will compile and run:
type MyString = String; fn main() { let haha: MyString = String::from(&amp;#34;haha&amp;#34;); let hehe: String = MyString::from(&amp;#34;hehe&amp;#34;); } “new type” struct wrapping If aliasing is not ideal, try this:
struct MyString(String); // a tuple Now, the following code will not compile since MyString and String are no longer interchangeable.</description>
    </item>
    
    <item>
      <title>Arrays, slices, and vectors</title>
      <link>https://www.mrr1vfe.io/posts/arrays-slices-and-vectors/</link>
      <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/arrays-slices-and-vectors/</guid>
      <description>Notes on Rust in Action, by Tim McNamara
Arrays  A collection of same thing (type). Size is not changeable. Size is known at compile time. Unlike arrays in Java, arrays in Rust are allocated on stack.  Array initialization  Comma-delimited list within square brackets [8, 9, 6, 4] Repeat expression [5; 10]: An array contains ten 5s.  Type annotation Similar to the repeat expression [type; size], the left hand side is the type of individual element, and the right hand side is the size of the array.</description>
    </item>
    
    <item>
      <title>Reading from user input</title>
      <link>https://www.mrr1vfe.io/posts/reading-from-user-input/</link>
      <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/reading-from-user-input/</guid>
      <description>Notes on Rust in Action, by Tim McNamara
Command line tooling A 3rd party crate called clap is better at handling command line arguments. GitHub - clap-rs/clap: A full featured, fast Command Line Argument Parser for Rust
use clap::{App, Arg}; fn main() { let args = App::new(&amp;#34;grep-lite&amp;#34;) .version(&amp;#34;0.1&amp;#34;) .about(&amp;#34;serach for patterns&amp;#34;) .arg( Arg::with_name(&amp;#34;pattern&amp;#34;) .help(&amp;#34;The pattern to search for&amp;#34;) .takes_value(true) .required(true), ) .arg( Arg::with_name(&amp;#34;input&amp;#34;) .help(&amp;#34;File to search&amp;#34;) .takes_value(true) .required(true), ) .get_matches(); let pattern = args.</description>
    </item>
    
    <item>
      <title>Some basic Rust</title>
      <link>https://www.mrr1vfe.io/posts/some-basic-rust/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/some-basic-rust/</guid>
      <description>Notes on Rust in Action, by Tim McNamara
Numbers Rust supports operator overloading. Therefore, operators like + can be used on different types, not only numbers (Java does not support it).
There is not implicit conversion between types. i32 is always i32 unless otherwise indicated.
Numbers have methods. But the type of a number must be specified.
To print the binary representation of a number, use {:b} as the placeholder for the number.</description>
    </item>
    
    <item>
      <title>Matrix Methods in Machine Learning</title>
      <link>https://www.mrr1vfe.io/posts/cs532/</link>
      <pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/cs532/</guid>
      <description>Unit 2  Linear Independence and Rank in Learning  Linear independence  A set of $M$ vectors $v_1, v_2, \cdots, v_m \in \mathbb{R}^N$ is linear independent if and only if \[\sum^M_{i=1} v_i\alpha_i = 0 \Leftrightarrow \alpha_i = 0, i = 1, 2, \cdots M.\] Otherwise, it&amp;#39;s called linearly dependent. A matrix multiplication of $Aw = d$ can be interpreted as the linear combination of the columns of $A$, where the weight for the $i^\text{th}$ column is the $i^\text{th}$ element of $w$.</description>
    </item>
    
    <item>
      <title>Compiling C code using GCC</title>
      <link>https://www.mrr1vfe.io/posts/matrix/</link>
      <pubDate>Mon, 17 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/matrix/</guid>
      <description>Basic compilation using GCC  gcc matrix.c  This command outputs a executable binary named a.out, which can be executed in the shell by ./a.out.
  Name the output binary file  a.out may not be a great name for the your binary, and using mv to rename a file every time after compilation is tedious. The -o flag allows users to name the output binary.
gcc matrix.c -o matrix  Run the program by .</description>
    </item>
    
    <item>
      <title>编译器的基本构造</title>
      <link>https://www.mrr1vfe.io/posts/contex-free-grammar/</link>
      <pubDate>Sat, 01 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/contex-free-grammar/</guid>
      <description>构造一个简单的编译器    目标   表达式中缀表示转化成后追表示
  过程   字符流 -&amp;gt; 词法分析器 -&amp;gt; 单词流 -&amp;gt; 语法制导翻译器 -&amp;gt; 中间表示形式
  语法制导翻译器   语法分析 + 中间代码生成
    context-free grammar (CFG)    context-free grammar   For a language L, its CFG defines the sets of strings of symbols that are valid sentences in L.
  sentence   A string of symbols that can be derived from the rules of a grammar.</description>
    </item>
    
    <item>
      <title>Introduction to Artifical Intelligence</title>
      <link>https://www.mrr1vfe.io/posts/cs540/</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/cs540/</guid>
      <description>Basic Python, comparing to Java 1    Why are we using python?   It has a large amount of better machine learning libraries.
  Useful link   Online Python compiler
  Key differences from Java	   Do not bother with a class unless you actually want to make an object.
  Functions do not need return types (or parameter types).</description>
    </item>
    
    <item>
      <title>Introduction to Operating Systems</title>
      <link>https://www.mrr1vfe.io/posts/cs537/</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/cs537/</guid>
      <description>Introduction 1  OS abstraction  Provide standard library to access resource that is valuable such as CPU, memory, and monitor. OS providing abstraction has a variety of advantages. It allows applications to reuse common facilities; it makes different devices look the same; and it provides higher-level or more useful functionality. The challenges of OS providing abstraction are identifying the correct abstraction and deciding how much of hardware should be exposed.</description>
    </item>
    
    <item>
      <title>Notes on The Rust Programming Language</title>
      <link>https://www.mrr1vfe.io/posts/trpl/</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/trpl/</guid>
      <description>Common Programming Concepts 1  Variables and Mutability    The default integer type for a positive number that is not so large is i32.
  Variables by default are immutable.
  Differences Between Variables and Constants    mut cannot be used with constants.
  Declare constants with const keyword, and the type must be annotated.
  Constant can only be set to constant expression, not value computed during runtime.</description>
    </item>
    
    <item>
      <title>Theory and Design of Programming Languages</title>
      <link>https://www.mrr1vfe.io/posts/cs538/</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/cs538/</guid>
      <description>Lecture 1 1  Functional programming  History    Based on $\lambda$ calculus
  Lisp
  ML
  Haskell
    Building block    function   take inputs as arguments and produce outputs.
  Functions are first class, like any other value. They can be passed to, returned by functions. Functions can also be combined into new function.</description>
    </item>
    
    <item>
      <title>Memory and Cache Review</title>
      <link>https://www.mrr1vfe.io/posts/memory-and-cache-review/</link>
      <pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.mrr1vfe.io/posts/memory-and-cache-review/</guid>
      <description>Locality  Principle of locality  Programs tend to use data and instructions with addresses near or equal to those they have recently used.
  temporal locality   Recently referenced items are likely to be referenced again in the near future.
  spatial locality   Items with nearby addresses tend to be referenced close together in time.
    Locality Example  sum = 0; for (int i = 0; i &amp;lt; n; i++) sum += a[i]; return sum;  Data References    Reference array elements in succession (stride - 1 reference pattern).</description>
    </item>
    
  </channel>
</rss>
